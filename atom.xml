<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gre的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-26T02:41:18.143Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhanggdong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>elasticsearch源码分析(三)Discover模块</title>
    <link href="http://yoursite.com/2018/05/27/elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)--Discover%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/05/27/elasticsearch源码分析(三)--Discover模块/</id>
    <published>2018-05-27T04:12:57.000Z</published>
    <updated>2018-06-26T02:41:18.143Z</updated>
    
    <content type="html"><![CDATA[<p>通过上一篇对Elasticsearch启动的分析，我们知道了ES启动的大致流程，还遗留下几个问题</p><ul><li>master选举是在什么模块进行的</li><li>ES集群是如何进行Master选举的？</li><li>ES是如何维护这些节点的？</li><li>Discovery模块是如何运作的？</li></ul><p>要想进行Master选举，必然要有一套算法机制，以及节点之前的通信连接、判断节点存活状态等。</p><p>通过查阅官网资料，我们知道这些功能是在Elasticsearch的发现协议Discovery里面进行的，在官网上，Elasticsearch的Discovery Module有下面几种实现：</p><ul><li><p>Azure Classic Discovery：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-discovery-azure-classic.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-discovery-azure-classic.html</a></p></li><li><p>EC2 Discovery：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-discovery-ec2.html#modules-discovery-ec2" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-discovery-ec2.html#modules-discovery-ec2</a></p></li><li><p>Google Compute Engine Discovery：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-discovery-gce.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-discovery-gce.html</a></p></li><li><p>Zen Discovery：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-discovery-zen.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-discovery-zen.html</a></p><p>​</p></li></ul><h4 id="一、Zen-Discovery模块介绍"><a href="#一、Zen-Discovery模块介绍" class="headerlink" title="一、Zen Discovery模块介绍"></a>一、Zen Discovery模块介绍</h4><p>这里基本上是官网的翻译，建议还是查看官网文档，翻译不准。。。</p><p>Zen Discovery是内置在elasticsearch的默认发现模块。它提供单播发现，但可扩展到支持云环境和其他形式的发现。</p><p>禅发现集成了其它模块，例如，节点之间的所有通信是使用transport模块。</p><p>它被分离成多个子模块，其解释如下：</p><h5 id="1-1-Ping"><a href="#1-1-Ping" class="headerlink" title="1.1 Ping"></a>1.1 Ping</h5><p>这是一个节点使用发现机制来查找其他节点的过程。</p><h5 id="1-2-Unicast"><a href="#1-2-Unicast" class="headerlink" title="1.2 Unicast"></a>1.2 Unicast</h5><p>单播发现需要一个主机列表，用于将作为GossipRouter。这些宿主可被指定为主机名或IP地址;指定主机名的主机每一轮Ping过程中解析为IP地址。请注意，如果您处于DNS解析度随时间变化的环境中，则可能需要调整<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/networkaddress-cache-ttl.html" title="Title" target="_blank" rel="noopener">JVM安全设置</a>。</p><p>建议将单播主机列表维护为集群中符合主节点的节点列表。</p><p>单播发现提供以下设置和<code>discovery.zen.ping.unicast</code>前缀：</p><table><thead><tr><th>设置</th><th>描述</th></tr></thead><tbody><tr><td><code>hosts</code></td><td>数组设置或逗号分隔的设置。每个值的形式应该是<code>host:port</code>或<code>host</code>（如果没有设置，<code>port</code>默认设置会<code>transport.profiles.default.port</code> 回落到<code>transport.tcp.port</code>）。请注意，IPv6主机必须放在括号内。默认为<code>127.0.0.1, [::1]</code></td></tr><tr><td><code>hosts.resolve_timeout</code></td><td>在每轮ping中等待DNS查找的时间量。指定为 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/common-options.html#time-units" target="_blank" rel="noopener">时间单位</a>。默认为5秒。</td></tr></tbody></table><p>单播发现使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-transport.html" target="_blank" rel="noopener">传输</a>模块执行发现。</p><h5 id="1-3-master选举"><a href="#1-3-master选举" class="headerlink" title="1.3 master选举"></a>1.3 master选举</h5><p>作为Ping过程的一部分，集群的主节点要么当选要么加入假期。这是自动完成的。ping的默认超时为3秒</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discovery.zen.ping_timeout（默认为3s）</span><br></pre></td></tr></table></figure><p>如果在超时后没有做出决定，则重新启动ping程序。在缓慢或拥塞的网络中，在作出选举决定之前，三秒可能不足以让节点意识到其环境中的其他节点。在这种情况下，应该谨慎地增加超时时间，因为这会减慢选举进程。一旦一个节点决定加入一个现有的已形成的集群，它将发送一个加入请求给主设备（<code>discovery.zen.join_timeout</code>）的超时默认值是ping超时的20倍。</p><p>当主节点停止或遇到问题时，群集节点会再次启动ping并选择新的主节点。这种ping测试也可以作为防止（部分）网络故障的保护，其中一个节点可能会不公正地认为主站发生故障。在这种情况下，节点将简单地从其他节点听到关于当前活动的主节点的信息。</p><p>如果<code>discovery.zen.master_election.ignore_non_master_pings</code>是<code>true</code>，没有参与资格（节点，其中节点坪<code>node.master</code>是<code>false</code>）的主选期间忽略; 默认值是 <code>false</code>。</p><p>可以通过设置<code>node.master</code>来排除节点成为主节点<code>false</code>。</p><p>该<code>discovery.zen.minimum_master_nodes</code>套需要加入新当选主为了选举完成并当选节点接受其主控权掌握合格节点的最小数量。相同的设置控制应该成为任何活动集群一部分的活动主节点合格节点的最小数量。如果不满足这个要求，活动的主节点将下台，新的主节点选举将开始。</p><p>此设置必须设置为您的主要合格节点的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/important-settings.html#minimum_master_nodes" target="_blank" rel="noopener">法定人数</a>。建议避免只有两个主节点，因为两个法定人数是两个。因此，任何主节点的损失都将导致无法运行的群集。</p><h5 id="1-4-故障检测"><a href="#1-4-故障检测" class="headerlink" title="1.4 故障检测"></a>1.4 故障检测</h5><p>有两个故障检测进程正在运行。第一种方法是通过主设备对群集中的所有其他节点进行ping操作，并验证它们是否处于活动状态。另一方面，每个节点都会主动确认它是否仍然存在或需要启动选举过程。</p><p>以下设置使用<code>discovery.zen.fd</code>前缀控制故障检测过程 ：</p><table><thead><tr><th>设置</th><th>描述</th></tr></thead><tbody><tr><td><code>ping_interval</code></td><td>一个节点多久发作一次。默认为<code>1s</code>。</td></tr><tr><td><code>ping_timeout</code></td><td>等待ping响应需要多长时间，默认为 <code>30s</code>。</td></tr><tr><td><code>ping_retries</code></td><td>有多少ping故障/超时会导致节点被视为失败。默认为<code>3</code>。</td></tr></tbody></table><h5 id="1-5-群集状态更新Cluster-state-updates"><a href="#1-5-群集状态更新Cluster-state-updates" class="headerlink" title="1.5 群集状态更新Cluster state updates"></a>1.5 群集状态更新Cluster state updates</h5><p>主节点是群集中，可以使改变集群状态的唯一节点。主节点一次处理一个集群状态更新，状态改变和发布更新的到集群中的所有其他节点。每个节点接收发布消息，确认它，但还没有立即应用它。如果主节点没有接收来自节点确认的数量至少为discovery.zen.minimum_master_nodes，在时间（由受控discovery.zen.commit_timeout设置，默认值为30秒）内。节点集群状态改变被拒绝。</p><p>一旦足够的节点已作出回应，集群状态改变被提交然后消息将被发送到所有结点。然后节点然后进行新的群集状态适用于他们的内部状态。主节点等待所有节点响应，在去队列处理下一个状态更新之前，直到超时，超时时间是在discovery.zen.publish_timeout默认情况下设置为30秒，时间从发布开始时测量h超时设置可以通过动态的改变集群更新设置API</p><h5 id="1-6-无主块No-master-block"><a href="#1-6-无主块No-master-block" class="headerlink" title="1.6 无主块No master block"></a>1.6 无主块No master block</h5><p>要使群集完全可操作，它必须具有活动的主节点和一些有主资格的节点，并且主资格的节点必须满足的数目必须满足<code>discovery.zen.minimum_master_nodes</code>设置的值。如果设置 <code>discovery.zen.no_master_block</code> ，那么设置控制在没有活动的主设备时应拒绝哪些操作。</p><p>该<code>discovery.zen.no_master_block</code>设置有两个有效选项：</p><table><thead><tr><th><code>all</code></th><th>节点上的所有操作（即读取和写入操作）都将被拒绝。这也适用于api集群状态读取或写入操作，如get索引设置，put映射和集群状态api。</th></tr></thead><tbody><tr><td><code>write</code></td><td>（默认）写入操作将被拒绝。基于最后一次已知的群集配置，读取操作将成功。这可能会导致部分读取过时的数据，因为此节点可能与群集的其余部分隔离。</td></tr></tbody></table><p>该<code>discovery.zen.no_master_block</code>设置不适用于基于节点的apis（例如，群集统计信息，节点信息和节点统计信息apis）。对这些apis的请求不会被阻止，并且可以在任何可用的节点上运行。</p><h5 id="1-7-Fault-Delection"><a href="#1-7-Fault-Delection" class="headerlink" title="1.7 Fault Delection"></a>1.7 Fault Delection</h5><p>用ping的方式来确定node是否在集群里面</p><h4 id="二、Discovery源码分析"><a href="#二、Discovery源码分析" class="headerlink" title="二、Discovery源码分析"></a>二、Discovery源码分析</h4><h5 id="2-1-Discovery类图"><a href="#2-1-Discovery类图" class="headerlink" title="2.1 Discovery类图"></a>2.1 Discovery类图</h5><p><img src="F:\hexo\source\images\es\ZenDiscovery类图.png" alt=":\hexo\source\images\es\ZenDiscovery类图.pn"></p><h5 id="2-2-与Discovery相关的几个类"><a href="#2-2-与Discovery相关的几个类" class="headerlink" title="2.2 与Discovery相关的几个类"></a>2.2 与Discovery相关的几个类</h5><p>ZenDiscovery.java 模块的主类，也是启动这个模块的入口，由Node.java调用并初始化，几乎涵盖了全部的发现协议的逻辑，是一个高度内聚了类，它有一些成员变量，需要明白他们的意思：</p><ul><li>pingTimeout：取自discovery.zen.ping_timeout（默认为3s）允许调整选举时间来处理网络慢或拥塞的情况（更高的值确保更少的失败机会）</li><li>joinTimeout：取自discovery.zen.join_timeout（默认值为ping超时的20倍）。当一个新的node加入集群时，将会发个join的request到master，这个request的timeout即joinTimeout。</li><li>joinRetryAttempts：join重试的次数，默认为3次。</li><li>joinRetryDelay：重试的间隔，默认为100ms。</li><li>maxPingsFromAnotherMaster：容忍其他master发出的,在强制其他或是本地master rejoin之前的次数。</li><li>masterElectionIgnoreNonMasters：用来控制在主节点选举时候的ping响应，只有在极端情况下才会使用这个参数，平时一般不用配置，默认值为false</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">有人说，选举master时，node.master为false的节点的投票是不起作用的，这个说法不完全正确：如果discovery.zen.master_election.ignore_non_master_pings设置为true，那么以上说法正确，但是默认是false，也就是说，它们的投票是起作用的，只是它们不可能成为master。所以我觉得，集群机器数不大的话，除了负担特别重的机器，都设置为node.master为true比较妥当。</span></span><br><span class="line"></span><br><span class="line"><span class="string">设置需要加入新一轮master选举的“master”候选人的最小数量</span></span><br><span class="line"><span class="string">也就是说，集群中，该值是针对那些node.master=true的来设置的，建议&gt;=num(node.master=true)/2+1.并不是有的朋友解释的，集群机器数量的除以2再加1，当然默认情况下是，因为默认情况下，discovery.zen.master_election.ignore_non_master_pings为false</span></span><br></pre></td></tr></table></figure><ul><li>masterElectionWaitForJoinsTimeout：master选举时等待join的timeout,默认是joinTimeout的一半。</li></ul><p>其中joinRetryAttempts和maxPingsFromAnotherMaster是一定要大于等于1的。</p><p>UnicastZenPing.java 是一个ZenPing 实现类，主要是负责底层和其他Nodes建立并维护连接的任务</p><p>PublishClusterStateAction.java 在<code>ZenDiscovery</code>中的变量名是<code>publishClusterState</code>，之前讲过，这些<code>**Action</code> 都是对<code>**Service</code>的封装，因此它主要是用来处理发送事件和处理事件的接口，比如发送一个<code>clusterStateChangeEvent</code> 和处理这个event，都是通过这个类调用</p><p>MasterFaultDetection.java 构建完cluster后所有的node用来检测master存活状态的类</p><p>NodeFaultDetection.java 构建完cluster后master用来检测其他node存活状态的类</p><h5 id="2-3-如何运行"><a href="#2-3-如何运行" class="headerlink" title="2.3 如何运行"></a>2.3 如何运行</h5><p>我们通过上一篇的分析知道，在ES启动的时候会去实例化Node，然后调用Node#start()方法启动各个module，Discovery是在实例化Node的时候通过guice进行注入的，在Node启动的时候去启动的，代码如下：</p><p>Node的构造函数中实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">final</span> DiscoveryModule discoveryModule = <span class="keyword">new</span> DiscoveryModule(<span class="keyword">this</span>.settings, threadPool, transportService,</span><br><span class="line">                namedWriteableRegistry, networkService, clusterService, pluginsService.filterPlugins(DiscoveryPlugin.class));</span><br><span class="line">...</span><br><span class="line">b.bind(Discovery.class).toInstance(discoveryModule.getDiscovery());</span><br></pre></td></tr></table></figure><h6 id="2-3-1-ZenDiscover的初始化"><a href="#2-3-1-ZenDiscover的初始化" class="headerlink" title="2.3.1 ZenDiscover的初始化"></a>2.3.1 ZenDiscover的初始化</h6><p>初始化的时候会加载我上段ZenDiscovery模块介绍提到的几个模块，我就不再重复了，值得注意的是Fault Delection的分为两个masterFD和nodesFD；其次还加载了一些对于discover的配置</p><h6 id="2-3-2-ZenDiscovery运行"><a href="#2-3-2-ZenDiscovery运行" class="headerlink" title="2.3.2 ZenDiscovery运行"></a>2.3.2 ZenDiscovery运行</h6><p>其实ZenDiscover的运行就是几个子模块的运行；它是通过Node#start()方法启动的。</p><p>在Node#start()方法中：我们可以看到Discovery相关的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Discovery discovery = injector.getInstance(Discovery.class);</span><br><span class="line">clusterService.setDiscoverySettings(discovery.getDiscoverySettings());</span><br><span class="line">clusterService.addInitialStateBlock(discovery.getDiscoverySettings().getNoMasterBlock());</span><br><span class="line">clusterService.setClusterStatePublisher(discovery::publish);</span><br><span class="line">...</span><br><span class="line"> <span class="comment">// start after cluster service so the local disco is known</span></span><br><span class="line">  discovery.start();</span><br><span class="line">  transportService.acceptIncomingRequests();</span><br><span class="line">  <span class="comment">// 核心方法</span></span><br><span class="line">  discovery.startInitialJoin();</span><br></pre></td></tr></table></figure><p>在DiscoveryModule类中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> Map&lt;String, Supplier&lt;Discovery&gt;&gt; discoveryTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        discoveryTypes.put(<span class="string">"zen"</span>,</span><br><span class="line">            () -&gt; <span class="keyword">new</span> ZenDiscovery(settings, threadPool, transportService, namedWriteableRegistry, clusterService, hostsProvider));</span><br><span class="line">        discoveryTypes.put(<span class="string">"none"</span>, () -&gt; <span class="keyword">new</span> NoneDiscovery(settings, clusterService, clusterService.getClusterSettings()));</span><br><span class="line">        discoveryTypes.put(<span class="string">"single-node"</span>, () -&gt; <span class="keyword">new</span> SingleNodeDiscovery(settings, clusterService));</span><br><span class="line">        <span class="keyword">for</span> (DiscoveryPlugin plugin : plugins) &#123;</span><br><span class="line">            plugin.getDiscoveryTypes(threadPool, transportService, namedWriteableRegistry,</span><br><span class="line">                clusterService, hostsProvider).entrySet().forEach(entry -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (discoveryTypes.put(entry.getKey(), entry.getValue()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot register discovery type ["</span> + entry.getKey() + <span class="string">"] twice"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">String discoveryType = DISCOVERY_TYPE_SETTING.get(settings);</span><br><span class="line">        <span class="comment">// 这里是函数式编程的用法，详情请百度或者Google</span></span><br><span class="line">        Supplier&lt;Discovery&gt; discoverySupplier = discoveryTypes.get(discoveryType);</span><br><span class="line">        <span class="keyword">if</span> (discoverySupplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown discovery type ["</span> + discoveryType + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Loggers.getLogger(getClass(), settings).info(<span class="string">"using discovery type [&#123;&#125;]"</span>, discoveryType);</span><br><span class="line">        discovery = Objects.requireNonNull(discoverySupplier.get());</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，这里Discovery的实例是由DisdcoveryModule的suppiler 提供。</p><p>discovery.start()方法调用AbstractLifecycleComponent#start()方法进行监听，同时在该start()方法中调用ZenDiscovery#doStart()方法进行真正工作，这里用到的模板方法的设计模式，在Spring中很多地方都是这样使用的，首先在抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// ES的生命周期zhuangt:INITIALIZED -&amp;gt; STARTED, STOPPED, CLOSED</span></span><br><span class="line">       <span class="comment">// 如果不可以启动，直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (!lifecycle.canMoveToStarted()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 启动之前循环监听</span></span><br><span class="line">       <span class="keyword">for</span> (LifecycleListener listener : listeners) &#123;</span><br><span class="line">           listener.beforeStart();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 调用ZenDiscovery的doStart()方法对一些变量进行初始化工作</span></span><br><span class="line">       doStart();</span><br><span class="line">       <span class="comment">// 处理状态</span></span><br><span class="line">       lifecycle.moveToStarted();</span><br><span class="line">       <span class="comment">// 启动之后的监听</span></span><br><span class="line">       <span class="keyword">for</span> (LifecycleListener listener : listeners) &#123;</span><br><span class="line">           listener.afterStart();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// 模板方法：由具体的Discovery类来实现，比如ZenDiscovery类</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>ZenDiscovery的start()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该方法其实就是做了一些初始化操作，不要被它的start()命名给误导</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 节点故障探测设置</span></span><br><span class="line">      nodesFD.setLocalNode(clusterService.localNode());</span><br><span class="line">      <span class="comment">// 调用连接线程控制类进行初始化操作</span></span><br><span class="line">      joinThreadControl.start();</span><br><span class="line">      <span class="comment">// 设置ping参数</span></span><br><span class="line">      zenPing.start(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.nodeJoinController = <span class="keyword">new</span> NodeJoinController(clusterService, allocationService, electMaster, settings);</span><br><span class="line">      <span class="keyword">this</span>.nodeRemovalExecutor = <span class="keyword">new</span> NodeRemovalClusterStateTaskExecutor(allocationService, electMaster, <span class="keyword">this</span>::submitRejoin, logger);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>discovery.startInitialJoin()方法分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInitialJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// start the join thread from a cluster state update. See &#123;@link JoinThreadControl&#125; for details.</span></span><br><span class="line">       clusterService.submitStateUpdateTask(<span class="string">"initial_join"</span>, <span class="keyword">new</span> LocalClusterUpdateTask() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ClusterTasksResult&lt;LocalClusterUpdateTask&gt; <span class="title">execute</span><span class="params">(ClusterState currentState)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="comment">// do the join on a different thread, the DiscoveryService waits for 30s anyhow till it is discovered</span></span><br><span class="line">               <span class="comment">// 调用这个方法进行详细的处理</span></span><br><span class="line">               joinThreadControl.startNewThreadIfNotRunning();</span><br><span class="line">               <span class="comment">// 返回LocalClusterUpdateTask</span></span><br><span class="line">               <span class="keyword">return</span> unchanged();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 加入集群失败后的逻辑：这里只是打印日志</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(String source, @org.elasticsearch.common.Nullable Exception e)</span> </span>&#123;</span><br><span class="line">               logger.warn(<span class="string">"failed to start initial join process"</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们通过上面的源码分析知道，joinThreadControl.startNewThreadIfNotRunning()这个方法是其核心处理逻辑，我们来看看它做了什么工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** starts a new joining thread if there is no currently active one and join thread controlling is started */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startNewThreadIfNotRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           ClusterService.assertClusterStateThread();</span><br><span class="line">           <span class="comment">// 如果join线程还存活，直接返回</span></span><br><span class="line">           <span class="keyword">if</span> (joinThreadActive()) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 从ES中的线程池获取generic线程池，然后提交一个任务</span></span><br><span class="line">           threadPool.generic().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   Thread currentThread = Thread.currentThread();</span><br><span class="line">                   <span class="comment">// CAS操作：</span></span><br><span class="line">                   <span class="keyword">if</span> (!currentJoinThread.compareAndSet(<span class="keyword">null</span>, currentThread)) &#123;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 第一次启动，这里的running肯定是true，是在之前的doStart()中进行初始化的</span></span><br><span class="line">                   <span class="keyword">while</span> (running.get() &amp;&amp; joinThreadActive(currentThread)) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">// 第一步：首先自己先加入集群</span></span><br><span class="line">                           innerJoinCluster();</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">.....</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>通过上面的分析我们知道，如果join线程还存活，则直接返回，否则从从ES中的线程池获取generic线程池，然后提交一个任务，在该任务中主要调用innerJoinCluster()方法加入集群。</p><p>我们来猜猜看看innerJoinCluster()方法做了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们要加入一个集群，肯定先要找到组织，熟悉Elasticsearch的配置都知道，我们的ES默认的集群名称是slasticsearch，如果配置了，则为我们配置的名称（有点废话了），肯定要进行master选举</span><br></pre></td></tr></table></figure><p>innerJoinCluster()方法分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">innerJoinCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DiscoveryNode masterNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> Thread currentThread = Thread.currentThread();</span><br><span class="line">        nodeJoinController.startElectionContext();</span><br><span class="line">        <span class="comment">// 通过findMaster方法来进行Master选举:</span></span><br><span class="line">        <span class="keyword">while</span> (masterNode == <span class="keyword">null</span> &amp;&amp; joinThreadControl.joinThreadActive(currentThread)) &#123;</span><br><span class="line">            masterNode = findMaster();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="三、master选举源码分析"><a href="#三、master选举源码分析" class="headerlink" title="三、master选举源码分析"></a>三、master选举源码分析</h4><p>阅读该部分源码，我们带着下面的一些问题去看。</p><ul><li>分布式系统设计思想？</li><li>ES为什么要master选举？</li><li>有哪些选举算法？</li><li>master选举主流程和详细流程？</li><li>什么时候触发选举？</li><li>为什么不用ZK来实现master选举？</li><li>如何获取到最新的状态数据？</li></ul><h5 id="3-1-分布式系统设计思想"><a href="#3-1-分布式系统设计思想" class="headerlink" title="3.1 分布式系统设计思想"></a>3.1 分布式系统设计思想</h5><p>所有的分布式系统都会遇到各个节点数据同步问题（一致性）、因网络故障存在的延迟、脑裂等问题都需要用一套合理的解决方案。比如，在互联网中比较经典的CAP理论和BASE理论。在ES中同样需要面临这样的问题？</p><h5 id="3-2-ES为什么要master选举"><a href="#3-2-ES为什么要master选举" class="headerlink" title="3.2 ES为什么要master选举"></a>3.2 ES为什么要master选举</h5><p>一种选择是分布式哈希表(DHT),可以支持每小时数千个节点的离开和加入,他可以在不了解底层网络拓扑的异构网络中工作,查询响应时间大约为4到10跳(中转次数)，但是在相对稳定的对等网络中,Master模式会更好</p><p>Elasticsearch的典型场景中的另一个简化是集群中没有那么多节点。 通常，节点的数量远远小于单个节点能够维护的连接数，并且网格环境不必经常处理节点加入和离开。 这就是为什么master的做法更适合Elasticsearch。</p><h5 id="3-3-选举算法"><a href="#3-3-选举算法" class="headerlink" title="3.3 选举算法"></a>3.3 选举算法</h5><h6 id="3-3-1-Bully算法"><a href="#3-3-1-Bully算法" class="headerlink" title="3.3.1 Bully算法"></a>3.3.1 Bully算法</h6><p>Leader选举的基本算法之一。 它假定所有节点都有一个惟一的ID，该ID对节点进行排序。 任何时候的当前Leader都是参与集群的最高id节点。 该算法的优点是易于实现,但是,当拥有最大 id 的节点处于不稳定状态的场景下会有问题,例如 Master 负载过重而假死,集群拥有第二大id 的节点被选为 新主,这时原来的 Master 恢复,再次被选为新主,然后又假死…</p><p>elasticsearch 通过推迟选举直到当前的 Master 失效来解决上述问题,但是容易产生脑裂,再通过 <em>法定得票人数过半</em> 解决脑裂</p><h6 id="3-3-2-Paxos算法"><a href="#3-3-2-Paxos算法" class="headerlink" title="3.3.2 Paxos算法"></a>3.3.2 Paxos算法</h6><p>Paxos实现起来非常复杂,但非常强大，尤其在什么时机,以及如何进行选举方面的灵活性比简单的Bully算法有很大的优势，因为在现实生活中，存在比网络链接异常更多的故障模式。比较典型的是Zookeeper在该算法进行了改进，形成自己的一套选举算法。</p><h5 id="3-4-选举流程"><a href="#3-4-选举流程" class="headerlink" title="3.4 选举流程"></a>3.4 选举流程</h5><p>只有一个 Leader将当前版本的全局集群状态推送到每个节点。 ZenDiscovery（默认）过程就是这样的:</p><ul><li>每个节点计算最低的已知节点ID，并向该节点发送领导投票</li><li>如果一个节点收到足够多的票数，并且该节点也为自己投票，那么它将扮演领导者的角色，开始发布集群状态。</li><li>所有节点都会参数选举,并参与投票,但是,只有有资格成为 master 的节点的投票才有效.</li></ul><p>有多少选票赢得选举的定义就是所谓的法定人数。 在弹性搜索中，法定大小是一个可配置的参数。 （一般配置成:可以成为master节点数n/2+1）</p><h5 id="3-5-选举详细流程"><a href="#3-5-选举详细流程" class="headerlink" title="3.5 选举详细流程"></a>3.5 选举详细流程</h5><h6 id="3-5-1-获取PingResponse列表"><a href="#3-5-1-获取PingResponse列表" class="headerlink" title="3.5.1 获取PingResponse列表"></a>3.5.1 获取PingResponse列表</h6><p>节奏上一个Discovery模块的源码进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DiscoveryNode <span class="title">findMaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.trace(<span class="string">"starting to ping"</span>);</span><br><span class="line">    <span class="comment">// ping所有节点并获取PingResponse</span></span><br><span class="line">    List&lt;ZenPing.PingResponse&gt; fullPingResponses = pingAndWait(pingTimeout).toList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ZenPing.<span class="function">PingCollection <span class="title">pingAndWait</span><span class="params">(TimeValue timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;ZenPing.PingCollection&gt; response = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 步骤2：ping所有节点，调用UnicastZenPing的ping()方法</span></span><br><span class="line">        zenPing.ping(response::complete, timeout);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从 <code>response::complete</code>和<code>response.get</code>两句大致就能猜猜，这个方法里面会异步发起请求，主线程等待response。</p><p>UnicastZenPing#ping()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ping</span><span class="params">(<span class="keyword">final</span> Consumer&lt;PingCollection&gt; resultsConsumer, <span class="keyword">final</span> TimeValue duration)</span> </span>&#123;</span><br><span class="line">        ping(resultsConsumer, duration, duration);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ping</span><span class="params">(<span class="keyword">final</span> Consumer&lt;PingCollection&gt; resultsConsumer,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">final</span> TimeValue scheduleDuration,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">final</span> TimeValue requestDuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;DiscoveryNode&gt; seedNodes;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            seedNodes = resolveHostsLists(</span><br><span class="line">                <span class="comment">// 1、从配置的discovery.zen.ping.unicast.hosts列表中获取</span></span><br><span class="line">                unicastZenPingExecutorService,</span><br><span class="line">                logger,</span><br><span class="line">                configuredHosts,</span><br><span class="line">                limitPortCounts,</span><br><span class="line">                transportService,</span><br><span class="line">                UNICAST_NODE_PREFIX,</span><br><span class="line">                resolveTimeout);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过其他方式添加seedNodes：List&lt;DiscoveryNode&gt;</span></span><br><span class="line">        seedNodes.addAll(hostsProvider.buildDynamicNodes());</span><br><span class="line">        <span class="comment">// 本实例最近一次的clusterState的masterNode</span></span><br><span class="line">        <span class="keyword">final</span> DiscoveryNodes nodes = contextProvider.clusterState().nodes();</span><br><span class="line">        <span class="comment">// add all possible master nodes that were active in the last known cluster configuration</span></span><br><span class="line">        <span class="comment">// 步骤3：添加有成为master资格的节点</span></span><br><span class="line">        <span class="keyword">for</span> (ObjectCursor&lt;DiscoveryNode&gt; masterNode : nodes.getMasterNodes().values()) &#123;</span><br><span class="line">            seedNodes.add(masterNode.value);</span><br><span class="line">        &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，在sendPing之前需要确定seedNodes（List<discoverynode>）,它从三个地方获取，第一，从配置的discovery.zen.ping.unicast.hosts列表中获取，第二、hostsProvider.buildDynamicNodes()中获取，最后，从本实例最近一次的clusterState的masterNode中获取。</discoverynode></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;DiscoveryNode&gt; <span class="title">resolveHostsLists</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// create tasks to submit to the executor service; we will wait up to resolveTimeout for these tasks to complete</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;Callable&lt;TransportAddress[]&gt;&gt; callables =</span><br><span class="line">            hosts</span><br><span class="line">                .stream()</span><br><span class="line">                <span class="comment">// 地址列表通过TransportService构造</span></span><br><span class="line">                .map(hn -&gt; (Callable&lt;TransportAddress[]&gt;) () -&gt; transportService.addressesFromString(hn, limitPortCounts))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 异步Future列表</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;Future&lt;TransportAddress[]&gt;&gt; futures =</span><br><span class="line">            executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS);</span><br><span class="line">        <span class="keyword">final</span> List&lt;DiscoveryNode&gt; discoveryNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Set&lt;TransportAddress&gt; localAddresses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        localAddresses.add(transportService.boundAddress().publishAddress());</span><br><span class="line">        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()));</span><br><span class="line">        <span class="comment">// ExecutorService#invokeAll guarantees that the futures are returned in the iteration order of the tasks so we can associate the</span></span><br><span class="line">        <span class="comment">// hostname with the corresponding task by iterating together</span></span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;String&gt; it = hosts.iterator();</span><br><span class="line">        <span class="comment">// 循环获取异步结果：就是简单的IP获取，为啥会用异步方式？</span></span><br><span class="line">        <span class="comment">// 猜猜是因为host中可能配置有域名，怕解析时间过长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Future&lt;TransportAddress[]&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">final</span> String hostname = it.next();</span><br><span class="line">            <span class="keyword">if</span> (!future.isCancelled()) &#123;</span><br><span class="line">                <span class="keyword">assert</span> future.isDone();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> TransportAddress[] addresses = future.get();</span><br><span class="line">                    logger.trace(<span class="string">"resolved host [&#123;&#125;] to &#123;&#125;"</span>, hostname, addresses);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> addressId = <span class="number">0</span>; addressId &lt; addresses.length; addressId++) &#123;</span><br><span class="line">                        <span class="keyword">final</span> TransportAddress address = addresses[addressId];</span><br><span class="line">                        <span class="comment">// no point in pinging ourselves</span></span><br><span class="line">                        <span class="keyword">if</span> (localAddresses.contains(address) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                            discoveryNodes.add(</span><br><span class="line">                                <span class="keyword">new</span> DiscoveryNode(</span><br><span class="line">                                    nodeId_prefix + hostname + <span class="string">"_"</span> + addressId + <span class="string">"#"</span>,</span><br><span class="line">                                    address,</span><br><span class="line">                                    emptyMap(),</span><br><span class="line">                                    emptySet(),</span><br><span class="line">                                    Version.CURRENT.minimumCompatibilityVersion()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">assert</span> e.getCause() != <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">final</span> String message = <span class="string">"failed to resolve host ["</span> + hostname + <span class="string">"]"</span>;</span><br><span class="line">                    logger.warn(message, e.getCause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"timed out after [&#123;&#125;] resolving host [&#123;&#125;]"</span>, resolveTimeout, hostname);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回List&lt;DiscoveryNode&gt;</span></span><br><span class="line">        <span class="keyword">return</span> discoveryNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到seedNodes之后就需要发起连接，这里会构造一个叫PingRound的类来统计，并且分别会在 scheduleDuration的0, 1/3, 2/3时刻发起一轮sendPing操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚开始启动，集群健康状态设置为RED</span></span><br><span class="line">        <span class="keyword">final</span> ConnectionProfile connectionProfile =</span><br><span class="line">            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration);</span><br><span class="line">        <span class="comment">// 构造一个叫PingRound的类来统计：这个类有id，seedNodes、pingListener、localNode等</span></span><br><span class="line">        <span class="keyword">final</span> PingingRound pingingRound = <span class="keyword">new</span> PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedNodes, resultsConsumer,</span><br><span class="line">            nodes.getLocalNode(), connectionProfile);</span><br><span class="line">        activePingingRounds.put(pingingRound.id(), pingingRound);</span><br><span class="line">        <span class="comment">// 构造ping发送对象pingSender</span></span><br><span class="line">        <span class="keyword">final</span> AbstractRunnable pingSender = <span class="keyword">new</span> AbstractRunnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AlreadyClosedException == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"unexpected error while pinging"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 发送sendPings</span></span><br><span class="line">                sendPings(requestDuration, pingingRound);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 提交线generic程池：ping的连接不像其他那样由transportService 来保持长连接，而是即建即销，的一条连接</span></span><br><span class="line">        <span class="comment">// 0</span></span><br><span class="line">        threadPool.generic().execute(pingSender);</span><br><span class="line">        <span class="comment">// 1/3</span></span><br><span class="line">        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / <span class="number">3</span>), ThreadPool.Names.GENERIC, pingSender);</span><br><span class="line">        <span class="comment">// 2/3</span></span><br><span class="line">        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / <span class="number">3</span> * <span class="number">2</span>), ThreadPool.Names.GENERIC, pingSender);</span><br><span class="line">        threadPool.schedule(scheduleDuration, ThreadPool.Names.GENERIC, <span class="keyword">new</span> AbstractRunnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 关闭临时连接</span></span><br><span class="line">                finishPingingRound(pingingRound);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                logger.warn(<span class="string">"unexpected error while finishing pinging round"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这里注意一点就是ping的连接不像其他那样由transportService 来保持长连接，而是即建即销，的一条连接。最后finishPingRound时则把这些临时连接关闭。</p><h6 id="3-5-2-选举master"><a href="#3-5-2-选举master" class="headerlink" title="3.5.2 选举master"></a>3.5.2 选举master</h6><p>再次回到findMaster()方法，上面ping完之后，我们拿到了一个fullPingResponses列表，这里有一个filter操作，如果我们启用了<code>discovery.zen.master_election.ignore_non_master_pings</code>则就会把那些node.master = false 那些节点都忽略掉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter responses</span></span><br><span class="line">        <span class="comment">// 如果我们启用了discovery.zen.master_election.ignore_non_master_pings则就会把那些node.master = false 那些节点都忽略掉：</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;ZenPing.PingResponse&gt; pingResponses = filterPingResponses(fullPingResponses, masterElectionIgnoreNonMasters, logger);</span><br></pre></td></tr></table></figure><p>紧接着就要从这些<code>pingResponse</code>里面收集其他节点当前的master节点是谁，最后拿到一个<code>activeMasters</code>的候选的名单，并把自己给去掉，Discovery的策略是非直到最后一刻都不会选自己为master（猜猜可能是预防脑裂吧）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//从pingResponse列表里面收集其他节点当前的master节点是谁，最后拿到一个activeMasters的候选的名单</span></span><br><span class="line">        List&lt;DiscoveryNode&gt; activeMasters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ZenPing.PingResponse pingResponse : pingResponses) &#123;</span><br><span class="line">            <span class="comment">// We can't include the local node in pingMasters list, otherwise we may up electing ourselves without</span></span><br><span class="line">            <span class="comment">// any check / verifications from other nodes in ZenDiscover#DiscoveryNode()</span></span><br><span class="line">            <span class="keyword">if</span> (pingResponse.master() != <span class="keyword">null</span> &amp;&amp; !localNode.equals(pingResponse.master())) &#123;</span><br><span class="line">                <span class="comment">// 添加master到activeMasters名单</span></span><br><span class="line">                activeMasters.add(pingResponse.master());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果可选名单为空，就是大家刚刚启动，则进入选举环节</span></span><br><span class="line">        <span class="keyword">if</span> (activeMasters.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 如果有足够的候选人参与:由discovery.zen.minimum_master_nodes参数指定</span></span><br><span class="line">            <span class="keyword">if</span> (electMaster.hasEnoughCandidates(masterCandidates)) &#123;</span><br><span class="line">                <span class="comment">// 具体的选举方法：非常简单，就是找到id为最小的节点</span></span><br><span class="line">                <span class="keyword">final</span> ElectMasterService.MasterCandidate winner = electMaster.electMaster(masterCandidates);</span><br><span class="line">                logger.trace(<span class="string">"candidate &#123;&#125; won election"</span>, winner);</span><br><span class="line">                <span class="keyword">return</span> winner.getNode();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// if we don't have enough master nodes, we bail, because there are not enough master to elect from</span></span><br><span class="line">                logger.warn(<span class="string">"not enough master nodes discovered during pinging (found [&#123;&#125;], but needed [&#123;&#125;]), pinging again"</span>,</span><br><span class="line">                            masterCandidates, electMaster.minimumMasterNodes());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> !activeMasters.contains(localNode) : <span class="string">"local node should never be elected as master when other nodes indicate an active master"</span>;</span><br><span class="line">            <span class="comment">// lets tie break between discovered nodes</span></span><br><span class="line">            <span class="keyword">return</span> electMaster.tieBreakActiveMasters(activeMasters);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接着就对这个候选列表判断，最理想就是列表为1，就证明你当前加入一个健康的集群中去，如果是有多个（正常情况下肯定不会有多个，除非你没有配置那个<code>discovery.zen.minimum_master_nodes</code>导致很多分治子群了）则在列表里面简单的选一个id号最小的（意思是不参乱了）。如果列表为空，就是大家都是刚启动，则进入选举环节，选举环节还是选出那个id最小的。</p><p>现在这个<code>masterNode</code>是定下来了，如果这个master是别人，则就简单的发送个join请求过去就好了，如果选出的master是你自己，那就还有一件很重要的事要做，还记得那个<code>discovery.zen.minimum_master_nodes</code>参数吗，一般要求这个值需要配成你的集群的cluster节点数的一半+1，以预防有脑裂，当前如果你选举出自己是master，那么你还需要等待 <code>minimumMasterNodes() - 1</code> 这么多个人join过来并认同你是master，那你才是真正的master，选举才结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面通过findMaster()方法找到masterNode，但是这时还不能算是真正的master节点</span></span><br><span class="line">        <span class="comment">// 如果选出了自己</span></span><br><span class="line">        <span class="keyword">if</span> (clusterService.localNode().equals(masterNode)) &#123;</span><br><span class="line">            <span class="comment">// 需要的节点数是discovery.zen.minimum_master_nodes-1（因为masterNode自己不需要表决了）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> requiredJoins = Math.max(<span class="number">0</span>, electMaster.minimumMasterNodes() - <span class="number">1</span>); <span class="comment">// we count as one</span></span><br><span class="line">            logger.debug(<span class="string">"elected as master, waiting for incoming joins ([&#123;&#125;] needed)"</span>, requiredJoins);</span><br><span class="line">            nodeJoinController.waitToBeElectedAsMaster(requiredJoins, masterElectionWaitForJoinsTimeout,</span><br><span class="line">                    <span class="keyword">new</span> NodeJoinController.ElectionCallback() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onElectedAsMaster</span><span class="params">(ClusterState state)</span> </span>&#123;</span><br><span class="line">                            joinThreadControl.markThreadAsDone(currentThread);</span><br><span class="line">                            <span class="comment">// we only starts nodesFD if we are master (it may be that we received a cluster state while pinging)</span></span><br><span class="line">                            nodesFD.updateNodesAndPing(state); <span class="comment">// start the nodes FD</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">                            logger.trace(<span class="string">"failed while waiting for nodes to join, rejoining"</span>, t);</span><br><span class="line">                            joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果这个master是别人，则就简单的发送个join请求过去就好了</span></span><br><span class="line">            <span class="comment">// process any incoming joins (they will fail because we are not the master)</span></span><br><span class="line">            nodeJoinController.stopElectionContext(masterNode + <span class="string">" elected"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// send join request</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> success = joinElectedMaster(masterNode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// finalize join through the cluster state update thread</span></span><br><span class="line">            <span class="keyword">final</span> DiscoveryNode finalMasterNode = masterNode;</span><br><span class="line">            clusterService.submitStateUpdateTask(<span class="string">"finalize_join ("</span> + masterNode + <span class="string">")"</span>, <span class="keyword">new</span> LocalClusterUpdateTask() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ClusterTasksResult&lt;LocalClusterUpdateTask&gt; <span class="title">execute</span><span class="params">(ClusterState currentState)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                        <span class="comment">// failed to join. Try again...</span></span><br><span class="line">                        joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</span><br><span class="line">                        <span class="keyword">return</span> unchanged();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentState.getNodes().getMasterNode() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Post 1.3.0, the master should publish a new cluster state before acking our join request. we now should have</span></span><br><span class="line">                        <span class="comment">// a valid master.</span></span><br><span class="line">                        logger.debug(<span class="string">"no master node is set, despite of join request completing. retrying pings."</span>);</span><br><span class="line">                        joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</span><br><span class="line">                        <span class="keyword">return</span> unchanged();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!currentState.getNodes().getMasterNode().equals(finalMasterNode)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> joinThreadControl.stopRunningThreadAndRejoin(currentState, <span class="string">"master_switched_while_finalizing_join"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Note: we do not have to start master fault detection here because it's set at &#123;@link #processNextPendingClusterState &#125;</span></span><br><span class="line">                    <span class="comment">// when the first cluster state arrives.</span></span><br><span class="line">                    joinThreadControl.markThreadAsDone(currentThread);</span><br><span class="line">                    <span class="keyword">return</span> unchanged();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(String source, @Nullable Exception e)</span> </span>&#123;</span><br><span class="line">                    logger.error(<span class="string">"unexpected error while trying to finalize cluster join"</span>, e);</span><br><span class="line">                    joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里会有一个等待join超时配置，超时后还没有满足数量的join请求，则选举失败，需要新一轮选举。</p><h6 id="3-6-什么时候触发Master选举"><a href="#3-6-什么时候触发Master选举" class="headerlink" title="3.6 什么时候触发Master选举"></a>3.6 什么时候触发Master选举</h6><ul><li>集群启动</li><li>Master 失效</li></ul><p>非 Master 节点运行的 MasterFaultDetection 检测到 Master 失效,在其注册的 listener 中执行 handleMasterGone,执行 rejoin 操作,重新选主.注意,即使一个节点认为 Master 失效也会进入选主流程</p><h6 id="3-7-为什么不用ZK？"><a href="#3-7-为什么不用ZK？" class="headerlink" title="3.7 为什么不用ZK？"></a>3.7 为什么不用ZK？</h6><p>个人猜测可能是当时ZK不是很流行，应用不广泛。Elasticsearch第一版发布于2010年，zookeeper发布于2008年，时间间隔不是很长。</p><h6 id="3-8-如何获取到最新的数据"><a href="#3-8-如何获取到最新的数据" class="headerlink" title="3.8 如何获取到最新的数据"></a>3.8 如何获取到最新的数据</h6><p>现在 Master 已成功当选,但是他未必有最新的 clusterState 信息,这些信息如何得到?<br>gateway 模块负责 clusterState 持久化和恢复,Master 节点在当选后,会通过下面的流程获取到集群最新 clusterState:</p><ul><li>枚举集群中有资格成为 Master 的节点列表</li><li>通过listGatewayMetaState获取这些节点上存储的 clusterState</li></ul><ol start="3"><li>对比这些节点的 clusterState 版本号,选择最新的作为 clusterState 并应用.</li></ol><font face="FireBrick">这一块将在后续的gateway源码分析模块中进行分析。</font><h5 id="3-9-总结master选举"><a href="#3-9-总结master选举" class="headerlink" title="3.9 总结master选举"></a>3.9 总结master选举</h5><h4 id="四、同步状态"><a href="#四、同步状态" class="headerlink" title="四、同步状态"></a>四、同步状态</h4><p>选举流程结束后两个重要的小task就开始工作了，分别是<code>MasterFaultDetection</code>和<code>NodesFaultDetection</code>，这两个task很简单，就拿一个master的来看，唯一不同就是node的里面保存的是cluster里面所有的nodes。</p><p>这两个是在ZenDiscovery初始化的时候就初始化好的Listener：MasterNodeFailureListener和NodeFaultDetectionListener分别是实现了MasterFaultDetection和NodesFaultDetection的内部类Listener。</p><p>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterNodeFailureListener</span> <span class="keyword">implements</span> <span class="title">MasterFaultDetection</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMasterFailure</span><span class="params">(DiscoveryNode masterNode, Throwable cause, String reason)</span> </span>&#123;</span><br><span class="line">            handleMasterGone(masterNode, cause, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeFaultDetectionListener</span> <span class="keyword">extends</span> <span class="title">NodesFaultDetection</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger pingsWhileMaster = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNodeFailure</span><span class="params">(DiscoveryNode node, String reason)</span> </span>&#123;</span><br><span class="line">            handleNodeFailure(node, reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPingReceived</span><span class="params">(<span class="keyword">final</span> NodesFaultDetection.PingRequest pingRequest)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// if we are master, we don't expect any fault detection from another node. If we get it</span></span><br><span class="line">            <span class="comment">// means we potentially have two masters in the cluster.</span></span><br><span class="line">            <span class="keyword">if</span> (!localNodeMaster()) &#123;</span><br><span class="line">                pingsWhileMaster.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pingsWhileMaster.incrementAndGet() &lt; maxPingsFromAnotherMaster) &#123;</span><br><span class="line">                logger.trace(<span class="string">"got a ping from another master &#123;&#125;. current ping count: [&#123;&#125;]"</span>, pingRequest.masterNode(), pingsWhileMaster.get());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.debug(<span class="string">"got a ping from another master &#123;&#125;. resolving who should rejoin. current ping count: [&#123;&#125;]"</span>, pingRequest.masterNode(), pingsWhileMaster.get());</span><br><span class="line">            clusterService.submitStateUpdateTask(<span class="string">"ping from another master"</span>, <span class="keyword">new</span> LocalClusterUpdateTask(Priority.IMMEDIATE) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> ClusterTasksResult&lt;LocalClusterUpdateTask&gt; <span class="title">execute</span><span class="params">(ClusterState currentState)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentState.nodes().isLocalNodeElectedMaster()) &#123;</span><br><span class="line">                        pingsWhileMaster.set(<span class="number">0</span>);</span><br><span class="line">                       </span><br><span class="line">                        <span class="keyword">return</span> handleAnotherMaster(currentState, pingRequest.masterNode(), pingRequest.clusterStateVersion(), <span class="string">"node fd ping"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> unchanged();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(String source, Exception e)</span> </span>&#123;</span><br><span class="line">                    logger.debug(<span class="string">"unexpected error during cluster state update task after pings from another master"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对与这两个类，我们只需要看run方法就行了</p><p>MasterFaultDetection#run()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// check if the master node did not get switched on us..., if it did, we simply return with no reschedule</span></span><br><span class="line">  <span class="keyword">if</span> (masterToPing.equals(MasterFaultDetection.<span class="keyword">this</span>.masterNode())) &#123;</span><br><span class="line">    <span class="comment">// we don't stop on disconnection from master, we keep pinging it</span></span><br><span class="line">     threadPool.schedule(pingInterval, ThreadPool.Names.SAME, MasterPinger.<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>和<code>findMaster（）</code>里面的不一样就是这里不再用temp连接而是在threadPool里面的长连接，这里对错误进行分类，如果是一些业务错误则不受尝试次数的限制，如请求的节点根本不是master节点，请求的master不是自己的cluster等等，会直接调用<code>notifyMasterFailure</code>回调，如果是常规错误，则记录尝试次数，当错误次数超过了阈值，则调用<code>notifyMasterFailure</code>回调。</p><p>接着看MasterNodeFailureListener的handleMasterGone()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleMasterGone</span><span class="params">(<span class="keyword">final</span> DiscoveryNode masterNode, <span class="keyword">final</span> Throwable cause, <span class="keyword">final</span> String reason)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 状态不是已经开始，则直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (lifecycleState() != Lifecycle.State.STARTED) &#123;</span><br><span class="line">           <span class="comment">// not started, ignore a master failure</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// master是自己也直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (localNodeMaster()) &#123;</span><br><span class="line">           <span class="comment">// we might get this on both a master telling us shutting down, and then the disconnect failure</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       logger.info((Supplier&lt;?&gt;) () -&gt; <span class="keyword">new</span> ParameterizedMessage(<span class="string">"master_left [&#123;&#125;], reason [&#123;&#125;]"</span>, masterNode, reason), cause);</span><br><span class="line"></span><br><span class="line">       clusterService.submitStateUpdateTask(<span class="string">"master_failed ("</span> + masterNode + <span class="string">")"</span>, <span class="keyword">new</span> LocalClusterUpdateTask(Priority.IMMEDIATE) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ClusterTasksResult&lt;LocalClusterUpdateTask&gt; <span class="title">execute</span><span class="params">(ClusterState currentState)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (!masterNode.equals(currentState.nodes().getMasterNode())) &#123;</span><br><span class="line">                   <span class="comment">// master got switched on us, no need to send anything</span></span><br><span class="line">                   <span class="keyword">return</span> unchanged();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// flush any pending cluster states from old master, so it will not be set as master again</span></span><br><span class="line">               publishClusterState.pendingStatesQueue().failAllStatesAndClear(<span class="keyword">new</span> ElasticsearchException(<span class="string">"master left [&#123;&#125;]"</span>, reason));</span><br><span class="line">               <span class="comment">// 重新进入rejion流程</span></span><br><span class="line">               <span class="keyword">return</span> rejoin(currentState, <span class="string">"master left (reason = "</span> + reason + <span class="string">")"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(String source, Exception e)</span> </span>&#123;</span><br><span class="line">               logger.error((Supplier&lt;?&gt;) () -&gt; <span class="keyword">new</span> ParameterizedMessage(<span class="string">"unexpected failure during [&#123;&#125;]"</span>, source), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在前面分析的Node初始化时，注册了clusterState的发布方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clusterService.setClusterStatePublisher(discovery::publish);</span><br></pre></td></tr></table></figure><p>我们来看看publish()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(ClusterChangedEvent clusterChangedEvent, AckListener ackListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!clusterChangedEvent.state().getNodes().isLocalNodeElectedMaster()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Shouldn't publish state when not master"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用PublishClusterStateAction的publish()方法</span></span><br><span class="line">            publishClusterState.publish(clusterChangedEvent, electMaster.minimumMasterNodes(), ackListener);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FailedToCommitClusterStateException t) &#123;</span><br><span class="line">            <span class="comment">// cluster service logs a WARN message</span></span><br><span class="line">            logger.debug(<span class="string">"failed to publish cluster state version [&#123;&#125;] (not enough nodes acknowledged, min master nodes [&#123;&#125;])"</span>, clusterChangedEvent.state().version(), electMaster.minimumMasterNodes());</span><br><span class="line">            submitRejoin(<span class="string">"zen-disco-failed-to-publish"</span>);</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the set of nodes to ping after the new cluster state has been published</span></span><br><span class="line">        nodesFD.updateNodesAndPing(clusterChangedEvent.state());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clean the pending cluster queue - we are currently master, so any pending cluster state should be failed</span></span><br><span class="line">        <span class="comment">// note that we also clean the queue on master failure (see handleMasterGone) but a delayed cluster state publish</span></span><br><span class="line">        <span class="comment">// from a stale master can still make it in the queue during the election (but not be committed)</span></span><br><span class="line">        publishClusterState.pendingStatesQueue().failAllStatesAndClear(<span class="keyword">new</span> ElasticsearchException(<span class="string">"elected as master"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用PublishClusterStateAction的publish()方法，在PublishClusterStateAction初始化的时候，会调用CommitClusterStateRequestHandler的构造方法，然后传递给TransportService的registerRequestHandler方法，最后会处理到一个pendingStatesQueue队列。</p><p>pendingStatesQueue会保存着每个待提交的state，并且也会提供最新的commit 的state给其他请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitClusterStateRequestHandler</span> <span class="keyword">implements</span> <span class="title">TransportRequestHandler</span>&lt;<span class="title">CommitClusterStateRequest</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(CommitClusterStateRequest request, <span class="keyword">final</span> TransportChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            handleCommitRequest(request, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleCommitRequest</span><span class="params">(CommitClusterStateRequest request, <span class="keyword">final</span> TransportChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ClusterState state = pendingStatesQueue.markAsCommitted(request.stateUUID,</span><br><span class="line">            <span class="keyword">new</span> PendingClusterStatesQueue.StateProcessedListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewClusterStateProcessed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// send a response to the master to indicate that this cluster state has been processed post committing it.</span></span><br><span class="line">                    channel.sendResponse(TransportResponse.Empty.INSTANCE);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"failed to send response on cluster state processed"</span>, e);</span><br><span class="line">                    onNewClusterStateFailed(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewClusterStateFailed</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.sendResponse(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception inner) &#123;</span><br><span class="line">                    inner.addSuppressed(e);</span><br><span class="line">                    logger.debug(<span class="string">"failed to send response on cluster state processed"</span>, inner);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newPendingClusterStatelistener.onNewClusterState(<span class="string">"master "</span> + state.nodes().getMasterNode() +</span><br><span class="line">                <span class="string">" committed version ["</span> + state.version() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而发布<code>clusterChangedEvent</code>则交给了<code>PublishClusterStateAction</code>主要逻辑在<code>innerPublish</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">innerPublish</span><span class="params">(<span class="keyword">final</span> ClusterChangedEvent clusterChangedEvent, <span class="keyword">final</span> Set&lt;DiscoveryNode&gt; nodesToPublishTo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> SendingController sendingController, <span class="keyword">final</span> <span class="keyword">boolean</span> sendFullVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> Map&lt;Version, BytesReference&gt; serializedStates, <span class="keyword">final</span> Map&lt;Version, BytesReference&gt; serializedDiffs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ClusterState clusterState = clusterChangedEvent.state();</span><br><span class="line">        <span class="keyword">final</span> ClusterState previousState = clusterChangedEvent.previousState();</span><br><span class="line">        <span class="keyword">final</span> TimeValue publishTimeout = discoverySettings.getPublishTimeout();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> publishingStartInNanos = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> DiscoveryNode node : nodesToPublishTo) &#123;</span><br><span class="line">            <span class="comment">// try and serialize the cluster state once (or per version), so we don't serialize it</span></span><br><span class="line">            <span class="comment">// per node when we send it over the wire, compress it while we are at it...</span></span><br><span class="line">            <span class="comment">// we don't send full version if node didn't exist in the previous version of cluster state</span></span><br><span class="line">            <span class="keyword">if</span> (sendFullVersion || !previousState.nodes().nodeExists(node)) &#123;</span><br><span class="line">                sendFullClusterState(clusterState, serializedStates, node, publishTimeout, sendingController);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是在ES2.x之后才有的，目的是为了减少网络带宽</span></span><br><span class="line">                sendClusterStateDiff(clusterState, serializedDiffs, serializedStates, node, publishTimeout, sendingController);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendingController.waitForCommit(discoverySettings.getCommitTimeout());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> timeLeftInNanos = Math.max(<span class="number">0</span>, publishTimeout.nanos() - (System.nanoTime() - publishingStartInNanos));</span><br><span class="line">            <span class="keyword">final</span> BlockingClusterStatePublishResponseHandler publishResponseHandler = sendingController.getPublishResponseHandler();</span><br><span class="line">            sendingController.setPublishingTimedOut(!publishResponseHandler.awaitAllNodes(TimeValue.timeValueNanos(timeLeftInNanos)));</span><br><span class="line">            <span class="keyword">if</span> (sendingController.getPublishingTimedOut()) &#123;</span><br><span class="line">                DiscoveryNode[] pendingNodes = publishResponseHandler.pendingNodes();</span><br><span class="line">                <span class="comment">// everyone may have just responded</span></span><br><span class="line">                <span class="keyword">if</span> (pendingNodes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"timed out waiting for all nodes to process published state [&#123;&#125;] (timeout [&#123;&#125;], pending nodes: &#123;&#125;)"</span>,</span><br><span class="line">                        clusterState.version(), publishTimeout, pendingNodes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ignore &amp; restore interrupt</span></span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在ES2.x 之后支持了发送临近版本的diff来同步状态，目的为了省网络带宽，点进去ClusterState类可以发现里面的状态信息量还是不少，不过diff 需要你的版本和目前的最新的版本只相差一个版本，如果你要从1跳到3需要发送full的状态。<code>sendFullClusterState</code> 和<code>sendClusterStateDiff</code>都会调用底层transportService来真正发送状态，而状态记录通过一个<code>sendingController</code>来维护，没接收到ack或者timeout都会让controller来check是否达到了<code>minMasterNodes-1</code>，达到则标记这次的状态推送commited，其余情况都会抛错。</p><p>这里一定需要注意，Publish状态分成两个阶段，首先是sendNotification</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendClusterStateToNode</span><span class="params">(<span class="keyword">final</span> ClusterState clusterState, BytesReference bytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> DiscoveryNode node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> TimeValue publishTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> SendingController sendingController,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> <span class="keyword">boolean</span> sendDiffs, <span class="keyword">final</span> Map&lt;Version, BytesReference&gt; serializedStates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// -&gt; no need to put a timeout on the options here, because we want the response to eventually be received</span></span><br><span class="line">            <span class="comment">//  and not log an error if it arrives after the timeout</span></span><br><span class="line">            <span class="comment">// -&gt; no need to compress, we already compressed the bytes</span></span><br><span class="line">            TransportRequestOptions options = TransportRequestOptions.builder()</span><br><span class="line">                .withType(TransportRequestOptions.Type.STATE).withCompress(<span class="keyword">false</span>).build();</span><br><span class="line">            transportService.sendRequest(node, SEND_ACTION_NAME,</span><br><span class="line">                    <span class="keyword">new</span> BytesTransportRequest(bytes, node.getVersion()),</span><br><span class="line">                    options,</span><br><span class="line">                    <span class="keyword">new</span> EmptyTransportResponseHandler(ThreadPool.Names.SAME) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(TransportResponse.Empty response)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (sendingController.getPublishingTimedOut()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"node &#123;&#125; responded for cluster state [&#123;&#125;] (took longer than [&#123;&#125;])"</span>, node,</span><br><span class="line">                                    clusterState.version(), publishTimeout);</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            sendingController.onNodeSendAck(node);</span><br><span class="line">                        &#125;</span><br><span class="line">                        ....</span><br><span class="line">                    &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>就是master先向所有节点发送这个状态，需要等minMasterNodes确认了这个通知，master节点才会把这个状态mark成commited，再<code>sendCommitToNode()</code> 告知所有节点把commited这个状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onNodeSendAck</span><span class="params">(DiscoveryNode node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (committed) &#123;</span><br><span class="line">                <span class="keyword">assert</span> sendAckedBeforeCommit.isEmpty();</span><br><span class="line">                sendCommitToNode(node, clusterState, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (committedOrFailed()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"ignoring ack from [&#123;&#125;] for cluster state version [&#123;&#125;]. already failed"</span>, node, clusterState.version());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we're still waiting</span></span><br><span class="line">                sendAckedBeforeCommit.add(node);</span><br><span class="line">                <span class="keyword">if</span> (node.isMasterNode()) &#123;</span><br><span class="line">                    checkForCommitOrFailIfNoPending(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其他Node消息处理也是在该类当中，大致流程就不再详细查看了，入口在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transportService.registerRequestHandler(SEND_ACTION_NAME, BytesTransportRequest::<span class="keyword">new</span>, ThreadPool.Names.SAME, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">          <span class="keyword">new</span> SendClusterStateRequestHandler());</span><br><span class="line">      transportService.registerRequestHandler(COMMIT_ACTION_NAME, CommitClusterStateRequest::<span class="keyword">new</span>, ThreadPool.Names.SAME, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">          <span class="keyword">new</span> CommitClusterStateRequestHandler());</span><br></pre></td></tr></table></figure><p>都会调用底层transportService来真正发送状态。</p><h4 id="五、Discovery模块总结"><a href="#五、Discovery模块总结" class="headerlink" title="五、Discovery模块总结"></a>五、Discovery模块总结</h4><p>从上面的源码分析我们知道，Discovery模块是ES的核心模块，它对ES集群进行master选举、状态发布和更新。</p><p><img src="F:\hexo\source\images\es\Discovery时序图.png" alt=":\hexo\source\images\es\Discovery时序图.pn"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过上一篇对Elasticsearch启动的分析，我们知道了ES启动的大致流程，还遗留下几个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master选举是在什么模块进行的&lt;/li&gt;
&lt;li&gt;ES集群是如何进行Master选举的？&lt;/li&gt;
&lt;li&gt;ES是如何维护这些节点的？&lt;/li&gt;

      
    
    </summary>
    
      <category term="Elasticsearch源码分析专题" scheme="http://yoursite.com/categories/Elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%93%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis面试题整理</title>
    <link href="http://yoursite.com/2018/05/26/redis/redis/"/>
    <id>http://yoursite.com/2018/05/26/redis/redis/</id>
    <published>2018-05-26T04:12:57.000Z</published>
    <updated>2018-06-20T01:13:19.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Redis为什么单线程的，能说说它的原理吗"><a href="#1、Redis为什么单线程的，能说说它的原理吗" class="headerlink" title="1、Redis为什么单线程的，能说说它的原理吗"></a>1、Redis为什么单线程的，能说说它的原理吗</h3><p>Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。Redis使用了单线程架构，预防了多线程可能产生的竞争问题，但是也会引入另外的问题。Redis单线程架构导致无法充分利用CPU多核特性，通常的做法是在一台机器上部署多个Redis实例。</p><p>那么Redis使用单线程模型，为什么还那么快：</p><p>第一，纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的重要基础。<br>第二，非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。</p><p>第三，单线程避免了线程切换和竞态产生的消耗。</p><h3 id="2、mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"><a href="#2、mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据" class="headerlink" title="2、mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据"></a>2、mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h3><p>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><h3 id="3、缓存穿透可以介绍⼀一下么？你认为应该如何解决这个问题"><a href="#3、缓存穿透可以介绍⼀一下么？你认为应该如何解决这个问题" class="headerlink" title="3、缓存穿透可以介绍⼀一下么？你认为应该如何解决这个问题"></a>3、缓存穿透可以介绍⼀一下么？你认为应该如何解决这个问题</h3><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库中查询。</p><p>解决思路：</p><p>1，如果查询<a href="http://cpro.baidu.com/cpro/ui/uijs.php?adclass=0&amp;app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=9d81f77002e20c6d&amp;k=%CA%FD%BE%DD%BF%E2&amp;k0=%CA%FD%BE%DD%BF%E2&amp;kdi0=0&amp;luki=7&amp;mcpm=0&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=6d0ce20270f7819d&amp;ssp2=1&amp;stid=9&amp;t=tpclicked3_hc&amp;td=1682280&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww.th7.cn%2Fdb%2Fnosql%2F201510%2F136276.shtml&amp;urlid=0" target="_blank" rel="noopener">数据库</a>也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。</p><p>2，根据缓存数据Key的规则。例如我们公司是做机顶盒的，缓存数据以Mac为Key，Mac是有规则，如果不符合规则就过滤掉，这样可以过滤一部分查询。在做缓存规划的时候，Key有一定规则的话，可以采取这种办法。这种办法只能缓解一部分的压力，过滤和系统无关的查询，但是无法根治。</p><p>3，采用布隆<a href="http://cpro.baidu.com/cpro/ui/uijs.php?adclass=0&amp;app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=9d81f77002e20c6d&amp;k=%B9%FD%C2%CB%C6%F7&amp;k0=%B9%FD%C2%CB%C6%F7&amp;kdi0=0&amp;luki=6&amp;mcpm=0&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=6d0ce20270f7819d&amp;ssp2=1&amp;stid=9&amp;t=tpclicked3_hc&amp;td=1682280&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww.th7.cn%2Fdb%2Fnosql%2F201510%2F136276.shtml&amp;urlid=0" target="_blank" rel="noopener">过滤器</a>，将所有可能存在的数据哈希到一个足够大的BitSet中，不存在的数据将会被拦截掉，从而避免了对<a href="http://cpro.baidu.com/cpro/ui/uijs.php?adclass=0&amp;app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=9d81f77002e20c6d&amp;k=%B5%D7%B2%E3&amp;k0=%B5%D7%B2%E3&amp;kdi0=0&amp;luki=2&amp;mcpm=0&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=6d0ce20270f7819d&amp;ssp2=1&amp;stid=9&amp;t=tpclicked3_hc&amp;td=1682280&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww.th7.cn%2Fdb%2Fnosql%2F201510%2F136276.shtml&amp;urlid=0" target="_blank" rel="noopener">底层</a>存储系统的查询压力。关于布隆<a href="http://cpro.baidu.com/cpro/ui/uijs.php?adclass=0&amp;app_id=0&amp;c=news&amp;cf=1001&amp;ch=0&amp;di=128&amp;fv=17&amp;is_app=0&amp;jk=9d81f77002e20c6d&amp;k=%B9%FD%C2%CB%C6%F7&amp;k0=%B9%FD%C2%CB%C6%F7&amp;kdi0=0&amp;luki=6&amp;mcpm=0&amp;n=10&amp;p=baidu&amp;q=smileking_cpr&amp;rb=0&amp;rs=1&amp;seller_id=1&amp;sid=6d0ce20270f7819d&amp;ssp2=1&amp;stid=9&amp;t=tpclicked3_hc&amp;td=1682280&amp;tu=u1682280&amp;u=http%3A%2F%2Fwww.th7.cn%2Fdb%2Fnosql%2F201510%2F136276.shtml&amp;urlid=0" target="_blank" rel="noopener">过滤器</a>，详情查看：基于BitSet的布隆过滤器(Bloom Filter) </p><p>大并发的缓存穿透会导致缓存雪崩。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Redis为什么单线程的，能说说它的原理吗&quot;&gt;&lt;a href=&quot;#1、Redis为什么单线程的，能说说它的原理吗&quot; class=&quot;headerlink&quot; title=&quot;1、Redis为什么单线程的，能说说它的原理吗&quot;&gt;&lt;/a&gt;1、Redis为什么单线程的，能说
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>elasticsearch源码分析(二)--启动</title>
    <link href="http://yoursite.com/2018/05/25/elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)--%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/05/25/elasticsearch源码分析(二)--启动/</id>
    <published>2018-05-25T04:10:57.000Z</published>
    <updated>2018-06-25T00:07:41.602Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近半年来一直在使用Elasticsearch来做全文检索和ELK统一日志工作，对于ES还是觉得需要细细研究，才能感受到它的魅力，才能有所提高。</p><p>我们先提出几个问题：</p><ul><li>启动入口在哪个类？</li><li>启动需要做哪些初始化工作？</li><li>如何加载配置文件？</li></ul><h4 id="一、怎么找启动入口在哪个类"><a href="#一、怎么找启动入口在哪个类" class="headerlink" title="一、怎么找启动入口在哪个类"></a>一、怎么找启动入口在哪个类</h4><p>看源码最头疼的事情就是找入口，相信很多刚开始也是这样，面对那么多模块中的类，很难找到一个切入点，我刚开始看也是这样，对于这样的问题，其实还是自己的积累不够，多学习就是了。</p><p>我们先来看看启动的脚本elasticsearch.bat或者elasticsearch.sh</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">忽略其他</span><br><span class="line"></span><br><span class="line"><span class="variable">%JAVA%</span> <span class="variable">%ES_JAVA_OPTS%</span> <span class="variable">%ES_PARAMS%</span> -cp "<span class="variable">%ES_CLASSPATH%</span>" "org.elasticsearch.bootstrap.Elasticsearch" <span class="variable">!newparams!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ENDLOCAL</span></span><br></pre></td></tr></table></figure><p>看到了org.elasticsearch.bootstrap.Elasticsearch这个类，不用想就是它的启动类。</p><h4 id="二、Elasticsearch类做了什么事情"><a href="#二、Elasticsearch类做了什么事情" class="headerlink" title="二、Elasticsearch类做了什么事情"></a>二、Elasticsearch类做了什么事情</h4><p>我们先来猜想一下，我们下载完Elasticsearch的安装包，一般有两种部署方式：单机部署和集群部署</p><h5 id="2-1-单机部署"><a href="#2-1-单机部署" class="headerlink" title="2.1 单机部署"></a>2.1 单机部署</h5><p>一般我们会修改{Elasticsearch_home}\config下的elasticsearch.yml文件和jvm.options</p><p>在elasticsearch.yml中配置集群名称、节点名称、日志存放路径、数据存放路径、网络IP、http端口（9200）、Netty端口（9300）等</p><p>同时还会去初始化一些module，如下图</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/es%E5%8D%95%E6%9C%BA%E5%90%AF%E5%8A%A8.png" alt=":\hexo\source\images\es\es单机启动.pn"></p><h5 id="2-2-集群部署"><a href="#2-2-集群部署" class="headerlink" title="2.2 集群部署"></a>2.2 集群部署</h5><p>我们会在单机部署的基础上，增加Discovery模块（集群发现）的配置、</p><p>有哪些节点参与到集群当中：discovery.zen.ping.unicast.hosts: [“host1”, “host2”]</p><p>需要有几个皇子在场才可以选举投票出master：discovery.zen.minimum_master_nodes: 3</p><h5 id="2-3-启动流程猜想"><a href="#2-3-启动流程猜想" class="headerlink" title="2.3 启动流程猜想"></a>2.3 启动流程猜想</h5><p>通过上述分析我们知道，ES集群启动会做一些初始化工作、加载配置文件，加载一下扩展插件，如果是集群启动，还会进行master选举，master选举需要有足够多的节点参与投票，这个参数是可以指定。</p><h4 id="三、启动源码分析"><a href="#三、启动源码分析" class="headerlink" title="三、启动源码分析"></a>三、启动源码分析</h4><h5 id="3-1-Elasticsearch类图"><a href="#3-1-Elasticsearch类图" class="headerlink" title="3.1 Elasticsearch类图"></a>3.1 Elasticsearch类图</h5><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/Elasticsearch%E7%B1%BB%E5%9B%BE.png" alt=":\hexo\source\images\es\Elasticsearch类图.pn"></p><h5 id="3-2-Elasticsearch-main-方法"><a href="#3-2-Elasticsearch-main-方法" class="headerlink" title="3.2 Elasticsearch#main()方法"></a>3.2 Elasticsearch#main()方法</h5><p>我们先来看看org.elasticsearch.bootstrap.Elasticsearch#main()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// we want the JVM to think there is a security manager installed so that if internal policy decisions that would be based on the</span></span><br><span class="line">        <span class="comment">// presence of a security manager or lack thereof act as if there is a security manager present (e.g., DNS cache policy)</span></span><br><span class="line">        System.setSecurityManager(<span class="keyword">new</span> SecurityManager() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// grant all permissions so that we can later set the security manager to the one that we want</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LogConfigurator.registerErrorListener();</span><br><span class="line">        <span class="comment">// 调用构造器</span></span><br><span class="line">        <span class="keyword">final</span> Elasticsearch elasticsearch = <span class="keyword">new</span> Elasticsearch();</span><br><span class="line">        <span class="comment">// 调用main方法，执行完后返回一个状态</span></span><br><span class="line">        <span class="keyword">int</span> status = main(args, elasticsearch, Terminal.DEFAULT);</span><br><span class="line">        <span class="comment">// 判断状态是否启动成功</span></span><br><span class="line">        <span class="keyword">if</span> (status != ExitCodes.OK) &#123;</span><br><span class="line">            exit(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args, <span class="keyword">final</span> Elasticsearch elasticsearch, <span class="keyword">final</span> Terminal terminal)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elasticsearch.main(args, terminal);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过上面的类图关系，我们知道Elasticsearch是一个Command，就是一开始先设置了一个SecurityManager，做一些检查checkPermission(Permission perm)，因此主要还是增加一些启停的hook，配置日志输出，用意看注释吧，接着打印了一些基本参数后则进入<code>init</code>方法，在Command#execute(terminal, options)方法里会调用<code>Bootstrap.init(!daemonize, pidFile, quiet, initialEnv);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(String[] args, Terminal terminal)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addShutdownHook()) &#123;</span><br><span class="line">            shutdownHookThread.set(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">                    <span class="keyword">try</span> (</span><br><span class="line">                        StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">                        PrintWriter pw = <span class="keyword">new</span> PrintWriter(sw)) &#123;</span><br><span class="line">                        e.printStackTrace(pw);</span><br><span class="line">                        terminal.println(sw.toString());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException impossible) &#123;</span><br><span class="line">                        <span class="comment">// StringWriter#close declares a checked IOException from the Closeable interface but the Javadocs for StringWriter</span></span><br><span class="line">                        <span class="comment">// say that an exception here is impossible</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(impossible);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="comment">// 当JVM关闭时，会执行系统中已经设置的所有通过方法addShutdownHook添加的钩子，</span></span><br><span class="line">            <span class="comment">// 当系统执行完这些钩子后，jvm才会关闭</span></span><br><span class="line">            Runtime.getRuntime().addShutdownHook(shutdownHookThread.get());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>配置日志输出Command#main()方法中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 配置日志输出</span><br><span class="line">// initialize default for es.logger.level because we will not read the log4j2.properties</span><br><span class="line">final String loggerLevel = System.getProperty(&quot;es.logger.level&quot;, Level.INFO.name());</span><br><span class="line">final Settings settings = Settings.builder().put(&quot;logger.level&quot;, loggerLevel).build();</span><br><span class="line">LogConfigurator.configureWithoutConfig(settings);</span><br></pre></td></tr></table></figure><p>LogConfigurator#configureWithoutConfig()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">configureWithoutConfig</span><span class="params">(<span class="keyword">final</span> Settings settings)</span> </span>&#123;</span><br><span class="line">     Objects.requireNonNull(settings);</span><br><span class="line">     <span class="comment">// we initialize the status logger immediately otherwise Log4j will complain when we try to get the context</span></span><br><span class="line">     configureStatusLogger();</span><br><span class="line">     configureLoggerLevels(settings);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在Command#mainWithoutErrorHandling(args, terminal)中执行Command，同时会抛出所有的异常给Command#main()方法，真正调用execute(terminal, options)方法执行操作，这是一个抽象方法，通过我们的类图,它的实现类应该是EnvironmentAwareCommand#execute()</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/Command-execute%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt=":\hexo\source\images\es\Command-execute实现类.pn"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Terminal terminal, OptionSet options)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将配置信息设置到HashMap中</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; settings = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> KeyValuePair kvp : settingOption.values(options)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kvp.value.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.USAGE, <span class="string">"setting ["</span> + kvp.key + <span class="string">"] must not be empty"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (settings.containsKey(kvp.key)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String message = String.format(</span><br><span class="line">                        Locale.ROOT,</span><br><span class="line">                        <span class="string">"setting [%s] already set, saw [%s] and [%s]"</span>,</span><br><span class="line">                        kvp.key,</span><br><span class="line">                        settings.get(kvp.key),</span><br><span class="line">                        kvp.value);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.USAGE, message);</span><br><span class="line">            &#125;</span><br><span class="line">            settings.put(kvp.key, kvp.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查了elasticsearch的三个环境参数：</span></span><br><span class="line">        putSystemPropertyIfSettingIsMissing(settings, <span class="string">"path.conf"</span>, <span class="string">"es.path.conf"</span>);</span><br><span class="line">        putSystemPropertyIfSettingIsMissing(settings, <span class="string">"path.data"</span>, <span class="string">"es.path.data"</span>);</span><br><span class="line">        putSystemPropertyIfSettingIsMissing(settings, <span class="string">"path.home"</span>, <span class="string">"es.path.home"</span>);</span><br><span class="line">        putSystemPropertyIfSettingIsMissing(settings, <span class="string">"path.logs"</span>, <span class="string">"es.path.logs"</span>);</span><br><span class="line">        <span class="comment">// 调用execute方法</span></span><br><span class="line">        execute(terminal, options, createEnv(terminal, settings));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法也是一个抽象方法，它有很多实现类</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/EnvironmentAwareCommand-execute%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt=":\hexo\source\images\es\EnvironmentAwareCommand-execute方法实现类.pn"></p><p>在该方法中，会先调用createEnv(terminal, settings)设置环境参数，使用该方法来加载配置文件信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Create an &#123;<span class="doctag">@link</span> Environment&#125; for the command to use. Overrideable for tests. */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Environment <span class="title">createEnv</span><span class="params">(Terminal terminal, Map&lt;String, String&gt; settings)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> InternalSettingsPreparer.prepareEnvironment(Settings.EMPTY, terminal, settings);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>那么这些配置信息怎么跟节点信息关联呢？</p><h5 id="3-3-Elasticsearch-execute-方法"><a href="#3-3-Elasticsearch-execute-方法" class="headerlink" title="3.3 Elasticsearch#execute()方法"></a>3.3 Elasticsearch#execute()方法</h5><p>直接来看Elasticsearch#execute()方法做了什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Terminal terminal, OptionSet options, Environment env)</span> <span class="keyword">throws</span> UserException </span>&#123;</span><br><span class="line">        <span class="comment">// 检查参数是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (options.nonOptionArguments().isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.USAGE, <span class="string">"Positional arguments not allowed, found "</span> + options.nonOptionArguments());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (options.has(versionOption)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (options.has(daemonizeOption) || options.has(pidfileOption)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.USAGE, <span class="string">"Elasticsearch version option is mutually exclusive with any other option"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            terminal.println(<span class="string">"Version: "</span> + org.elasticsearch.Version.CURRENT</span><br><span class="line">                    + <span class="string">", Build: "</span> + Build.CURRENT.shortHash() + <span class="string">"/"</span> + Build.CURRENT.date()</span><br><span class="line">                    + <span class="string">", JVM: "</span> + JvmInfo.jvmInfo().version());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否以守护线程启动（后台启动 -d）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> daemonize = options.has(daemonizeOption);</span><br><span class="line">        <span class="comment">// 进程文件</span></span><br><span class="line">        <span class="keyword">final</span> Path pidFile = pidfileOption.value(options);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> quiet = options.has(quietOption);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行初始化方法</span></span><br><span class="line">            init(daemonize, pidFile, quiet, env);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NodeValidationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UserException(ExitCodes.CONFIG, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法主要是检查一些参数，然后调用Elasticsearch#init(daemonize, pidFile, quiet, env)方法，在方法里会调用<code>Bootstrap.init(!daemonize, pidFile, quiet, initialEnv)</code>，而这个方法才是Elasticsearch真正去启动ES。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked by &#123;<span class="doctag">@link</span> Elasticsearch#main(String[])&#125; to startup elasticsearch.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">boolean</span> foreground,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> Path pidFile,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> <span class="keyword">boolean</span> quiet,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> Environment initialEnv)</span> <span class="keyword">throws</span> BootstrapException, NodeValidationException, UserException </span>&#123;</span><br><span class="line">        <span class="comment">// Set the system property before anything has a chance to trigger its use</span></span><br><span class="line">        initLoggerPrefix();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// force the class initializer for BootstrapInfo to run before</span></span><br><span class="line">        <span class="comment">// the security manager is installed</span></span><br><span class="line">        BootstrapInfo.init();</span><br><span class="line"></span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">final</span> SecureSettings keystore = loadSecureSettings(initialEnv);</span><br><span class="line">        Environment environment = createEnvironment(foreground, pidFile, keystore, initialEnv.settings());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 配置日志输出</span></span><br><span class="line">            LogConfigurator.configure(environment);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查自定义配置文件</span></span><br><span class="line">        checkForCustomConfFile();</span><br><span class="line">        <span class="comment">// 检查是否配置错误</span></span><br><span class="line">        checkConfigExtension(environment.configExtension());</span><br><span class="line">        <span class="comment">// 如果pidFile文件不为空，则创建pid文件，会在磁盘上持久化一个记录应用pid的文件</span></span><br><span class="line">        <span class="keyword">if</span> (environment.pidFile() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PidFile.create(environment.pidFile(), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过参数foreground和quiet来控制日志输出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> closeStandardStreams = (foreground == <span class="keyword">false</span>) || quiet;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeStandardStreams) &#123;</span><br><span class="line">                <span class="keyword">final</span> Logger rootLogger = ESLoggerFactory.getRootLogger();</span><br><span class="line">                <span class="keyword">final</span> Appender maybeConsoleAppender = Loggers.findAppender(rootLogger, ConsoleAppender.class);</span><br><span class="line">                <span class="keyword">if</span> (maybeConsoleAppender != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Loggers.removeAppender(rootLogger, maybeConsoleAppender);</span><br><span class="line">                &#125;</span><br><span class="line">                closeSystOut();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fail if somebody replaced the lucene jars</span></span><br><span class="line">            checkLucene();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// install the default uncaught exception handler; must be done before security is</span></span><br><span class="line">            <span class="comment">// initialized as we do not want to grant the runtime permission</span></span><br><span class="line">            <span class="comment">// setDefaultUncaughtExceptionHandler</span></span><br><span class="line">            <span class="comment">// 初始化节点信息</span></span><br><span class="line">            Thread.setDefaultUncaughtExceptionHandler(</span><br><span class="line">                <span class="keyword">new</span> ElasticsearchUncaughtExceptionHandler(() -&gt; Node.NODE_NAME_SETTING.get(environment.settings())));</span><br><span class="line">            <span class="comment">// 调用Bootstrap的setup方法和start方法</span></span><br><span class="line">            INSTANCE.setup(<span class="keyword">true</span>, environment);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// any secure settings must be read during node construction</span></span><br><span class="line">                IOUtils.close(keystore);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用Bootstrap的start方法</span></span><br><span class="line">            INSTANCE.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (closeStandardStreams) &#123;</span><br><span class="line">                closeSysError();</span><br><span class="line">            &#125;</span><br><span class="line">            ... 略</span><br></pre></td></tr></table></figure><p>参数详解</p><ul><li>foreground：标识elasticsearch是否是作为后台守护进程启动的，</li><li>pidFile：通过parser解析args后得到，实际是解析了默认命令行参数（verbose，E,silent，version，help，quiet，daemonize，pidfile）</li><li>quiet：同上</li><li>initialEnv：Environment实例化的环境参数对象，保存了一些类似于repoFile，configFile，pluginsFile，binFile，libFile等参数。</li></ul><p>通过上述的源码阅读，我们发现在该方法中：</p><p>主要工作</p><ul><li>首先会实例化一个Bootstrap对象</li><li>配置log输出器</li><li>创建pid文件，会在磁盘上持久化一个记录应用pid的文件</li><li>通过参数foreground和quiet来控制日志输出</li><li>调用Bootstrap的setup方法和start方法</li></ul><h5 id="3-5-Bootstrap-setup-方法"><a href="#3-5-Bootstrap-setup-方法" class="headerlink" title="3.5 Bootstrap#setup()方法"></a>3.5 Bootstrap#setup()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup(<span class="keyword">boolean</span> addShutdownHook, Environment environment)<span class="keyword">throws</span> BootstrapException</span><br></pre></td></tr></table></figure><p>该方法主要工作</p><ul><li>通过environment生成本地插件控制器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Settings settings = environment.settings();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Spawner类是一个Environment本地插件控制器</span></span><br><span class="line">            spawner.spawnNativePluginControllers(environment);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><p>初始化本地资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initializeNatives(</span><br><span class="line">                environment.tmpFile(),</span><br><span class="line">                BootstrapSettings.MEMORY_LOCK_SETTING.get(settings),</span><br><span class="line">                BootstrapSettings.SYSTEM_CALL_FILTER_SETTING.get(settings),</span><br><span class="line">                BootstrapSettings.CTRLHANDLER_SETTING.get(settings));</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>在安全管理器安装之前初始化探针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initializeProbes();</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>添加关闭钩子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (addShutdownHook) &#123;</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        IOUtils.close(node, spawner);</span><br><span class="line">                        LoggerContext context = (LoggerContext) LogManager.getContext(<span class="keyword">false</span>);</span><br><span class="line">                        Configurator.shutdown(context);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ElasticsearchException(<span class="string">"failed to stop node"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>检查jar重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// look for jar hell,检查jar重复</span></span><br><span class="line">            JarHell.checkJarHell();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | URISyntaxException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>在安全管理器安装之前配置日志输出器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install SM after natives, shutdown hooks, etc.</span></span><br><span class="line">        <span class="comment">// 安装安全管理器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>安装安全管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install SM after natives, shutdown hooks, etc.</span></span><br><span class="line">        <span class="comment">// 安装安全管理器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Security.configure(environment,               BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BootstrapException(e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>通过参数environment实例化Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过参数environment实例化Node</span></span><br><span class="line">        node = <span class="keyword">new</span> Node(environment) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateNodeBeforeAcceptingRequests</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> Settings settings,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> BoundTransportAddress boundTransportAddress, List&lt;BootstrapCheck&gt; checks)</span> <span class="keyword">throws</span> NodeValidationException </span>&#123;</span><br><span class="line">                BootstrapChecks.check(settings, boundTransportAddress, checks);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h5 id="3-6-Bootstrap-start-方法"><a href="#3-6-Bootstrap-start-方法" class="headerlink" title="3.6 Bootstrap#start()方法"></a>3.6 Bootstrap#start()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> NodeValidationException </span>&#123;</span><br><span class="line">       node.start();</span><br><span class="line">       keepAliveThread.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>主要工作</p><ul><li><p>启动已经实例化的Node</p></li><li><p>启动keepAliveThread 线程，这个线程在Bootstrap初始化的时候就已经实例化了，该线程创建了一个计数为1的CountDownLatch，目的是在启动完成后能顺利添加关闭钩子，而这句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread())</span><br></pre></td></tr></table></figure><p>意思就是在jvm中增加一个关闭的钩子，当jvm关闭的时候，会执行系统中已经设置的所有通过方法addShutdownHook添加的钩子，当系统执行完这些钩子后，jvm才会关闭。所以这些钩子可以在jvm关闭的时候进行内存清理、对象销毁等操作。<br>可以看到启动的重点在setup方法中，启动过后就是Node的事了。</p><p>keepAliveThhread线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch keepAliveLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/** creates a new instance */</span></span><br><span class="line">    Bootstrap() &#123;</span><br><span class="line">        <span class="comment">// 在构造器中就创建keepAliveThread线程</span></span><br><span class="line">        keepAliveThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keepAliveLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// bail out</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"elasticsearch[keepAlive/"</span> + Version.CURRENT + <span class="string">"]"</span>);</span><br><span class="line">        keepAliveThread.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// keep this thread alive (non daemon thread) until we shutdown</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 这里的钩子执行完毕，才会执行完keepAliveThread线程的run()方法</span></span><br><span class="line">                keepAliveLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-4-Node类源码解读"><a href="#3-4-Node类源码解读" class="headerlink" title="3.4 Node类源码解读"></a>3.4 Node类源码解读</h5><p>我们先不看源码，如果是你，会怎么去设计这个Node类？会怎么去加载配置文件信息？</p><p>猜想，我们启动ES都是一个节点Node，如果是集群，会有多个Node，那么我们应该也是通过Node来加载配置文件，加载完配置文件构造一个Config对象，最后初始化一个Node对象。</p><p>继续猜想，Node应该是包含一些基本信息、全局环境配置Setting和Environment，节点环境NodeEnvironment、是否为master、是否可以参与投票等。</p><p>问题：这些信息设置完毕，如何启动、如何停止？如何加载插件？</p><p>验证猜想，查看类的定义信息</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/Node%E5%AE%9A%E4%B9%891.png" alt=":\hexo\source\images\es\Node定义1.pn"></p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/Node%E5%AE%9A%E4%B9%89.png" alt=":\hexo\source\images\es\Node定义.pn"></p><h6 id="3-4-1-Node初始化"><a href="#3-4-1-Node初始化" class="headerlink" title="3.4.1 Node初始化"></a>3.4.1 Node初始化</h6><p>我们前面通过分析Bootstrap#setup()方法知道，Node的实例化是在该方法中调用 new Node(environment)进行的，节点的启动是在Bootstrap#start()方法中调用Node#start()方法进行启动的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过参数environment实例化Node</span></span><br><span class="line">        node = <span class="keyword">new</span> Node(environment) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateNodeBeforeAcceptingRequests</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> Settings settings,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> BoundTransportAddress boundTransportAddress, List&lt;BootstrapCheck&gt; checks)</span> <span class="keyword">throws</span> NodeValidationException </span>&#123;</span><br><span class="line">                BootstrapChecks.check(settings, boundTransportAddress, checks);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>使用google的注入框架Guice的Injector进行注入与获取实例。elasticsearch里面的组件都是用上面的方法进行模块化管理，elasticsearch对guice进行了封装，通过ModulesBuilder类构建elasticsearch的模块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ModulesBuilder modules = <span class="keyword">new</span> ModulesBuilder();</span><br><span class="line">            <span class="comment">// plugin modules must be added here, before others or we can get crazy injection errors...</span></span><br><span class="line">            <span class="keyword">for</span> (Module pluginModule : pluginsService.createGuiceModules()) &#123;</span><br><span class="line">                modules.add(pluginModule);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> MonitorService monitorService = <span class="keyword">new</span> MonitorService(settings, nodeEnvironment, threadPool);</span><br><span class="line">            modules.add(<span class="keyword">new</span> NodeModule(<span class="keyword">this</span>, monitorService));</span><br><span class="line">            ClusterModule clusterModule = <span class="keyword">new</span> ClusterModule(settings, clusterService,</span><br><span class="line">                pluginsService.filterPlugins(ClusterPlugin.class));</span><br><span class="line">            modules.add(clusterModule);</span><br><span class="line">            IndicesModule indicesModule = <span class="keyword">new</span> IndicesModule(pluginsService.filterPlugins(MapperPlugin.class));</span><br><span class="line">            modules.add(indicesModule);</span><br><span class="line"></span><br><span class="line">            SearchModule searchModule = <span class="keyword">new</span> SearchModule(settings, <span class="keyword">false</span>, pluginsService.filterPlugins(SearchPlugin.class));</span><br><span class="line">            CircuitBreakerService circuitBreakerService = createCircuitBreakerService(settingsModule.getSettings(),</span><br><span class="line">                settingsModule.getClusterSettings());</span><br><span class="line">            resourcesToClose.add(circuitBreakerService);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Node的实例化主要工作：</p><ul><li>设置初始化信息：nodeEnvironment</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            Settings tmpSettings = Settings.builder().put(environment.settings())</span><br><span class="line">                .put(Client.CLIENT_TYPE_SETTING_S.getKey(), CLIENT_TYPE).build();</span><br><span class="line"></span><br><span class="line">            tmpSettings = TribeService.processSettings(tmpSettings);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create the node environment as soon as possible, to recover the node id and enable logging</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                nodeEnvironment = <span class="keyword">new</span> NodeEnvironment(tmpSettings, environment);</span><br><span class="line">                resourcesToClose.add(nodeEnvironment);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to create node environment"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> hadPredefinedNodeName = NODE_NAME_SETTING.exists(tmpSettings);</span><br><span class="line">            Logger logger = Loggers.getLogger(Node.class, tmpSettings);</span><br><span class="line">            <span class="keyword">final</span> String nodeId = nodeEnvironment.nodeId();</span><br><span class="line">            tmpSettings = addNodeNameIfNeeded(tmpSettings, nodeId);</span><br><span class="line">            <span class="keyword">if</span> (DiscoveryNode.nodeRequiresLocalStorage(tmpSettings)) &#123;</span><br><span class="line">                checkForIndexDataInDefaultPathData(tmpSettings, nodeEnvironment, logger);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// this must be captured after the node name is possibly added to the settings</span></span><br><span class="line">            <span class="keyword">final</span> String nodeName = NODE_NAME_SETTING.get(tmpSettings);</span><br><span class="line">            <span class="keyword">if</span> (hadPredefinedNodeName == <span class="keyword">false</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">"node name [&#123;&#125;] derived from node ID [&#123;&#125;]; set [&#123;&#125;] to override"</span>, nodeName, nodeId, NODE_NAME_SETTING.getKey());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(<span class="string">"node name [&#123;&#125;], node ID [&#123;&#125;]"</span>, nodeName, nodeId);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li><p>打印JVM信息</p><p>​</p></li><li><p>初始化pluginsService类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.pluginsService = <span class="keyword">new</span> PluginsService(tmpSettings, environment.modulesFile(), environment.pluginsFile(), classpathPlugins);</span><br></pre></td></tr></table></figure><ul><li><p>environment(这里会加载配置文件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.environment = <span class="keyword">new</span> Environment(<span class="keyword">this</span>.settings);</span><br><span class="line">Environment.assertEquivalent(environment, <span class="keyword">this</span>.environment);</span><br></pre></td></tr></table></figure></li><li><p>Executors 和threadPool</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;ExecutorBuilder&lt;?&gt;&gt; executorBuilders = pluginsService.getExecutorBuilders(settings);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ThreadPool threadPool = <span class="keyword">new</span> ThreadPool(settings, executorBuilders.toArray(<span class="keyword">new</span> ExecutorBuilder[<span class="number">0</span>]));</span><br><span class="line">resourcesToClose.add(() -&gt; ThreadPool.terminate(threadPool, <span class="number">10</span>, TimeUnit.SECONDS));</span><br><span class="line"><span class="comment">// adds the context to the DeprecationLogger so that it does not need to be injected everywhere</span></span><br><span class="line">DeprecationLogger.setThreadContext(threadPool.getThreadContext());</span><br><span class="line">resourcesToClose.add(() -&gt; DeprecationLogger.removeThreadContext(threadPool.getThreadContext()));</span><br></pre></td></tr></table></figure><p>我们来看es线程池做了什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">final</span> Settings settings, <span class="keyword">final</span> ExecutorBuilder&lt;?&gt;... customBuilders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(settings);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> Node.NODE_NAME_SETTING.exists(settings);</span><br><span class="line">        <span class="comment">// 将构造好的线程池添加到HashMap中，key是线程池的名称，value是ExecutorBuilder</span></span><br><span class="line">        <span class="comment">// 每一个线程都是通过ExecutorBuilder来构造</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, ExecutorBuilder&gt; builders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> availableProcessors = EsExecutors.boundedNumberOfProcessors(settings);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfProcMaxAt5 = halfNumberOfProcessorsMaxFive(availableProcessors);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfProcMaxAt10 = halfNumberOfProcessorsMaxTen(availableProcessors);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> genericThreadPoolMax = boundedBy(<span class="number">4</span> * availableProcessors, <span class="number">128</span>, <span class="number">512</span>);</span><br><span class="line">        builders.put(Names.GENERIC, <span class="keyword">new</span> ScalingExecutorBuilder(Names.GENERIC, <span class="number">4</span>, genericThreadPoolMax, TimeValue.timeValueSeconds(<span class="number">30</span>)));</span><br><span class="line">        builders.put(Names.INDEX, <span class="keyword">new</span> FixedExecutorBuilder(settings, Names.INDEX, availableProcessors, <span class="number">200</span>));</span><br><span class="line">        builders.put(Names.BULK, <span class="keyword">new</span> FixedExecutorBuilder(settings, Names.BULK, availableProcessors, <span class="number">200</span>)); <span class="comment">// now that we reuse bulk for index/delete ops</span></span><br><span class="line">        builders.put(Names.GET, <span class="keyword">new</span> FixedExecutorBuilder(settings, Names.GET, availableProcessors, <span class="number">1000</span>));</span><br><span class="line">        builders.put(Names.SEARCH, <span class="keyword">new</span> FixedExecutorBuilder(settings, Names.SEARCH, searchThreadPoolSize(availableProcessors), <span class="number">1000</span>));</span><br><span class="line">        builders.put(Names.MANAGEMENT, <span class="keyword">new</span> ScalingExecutorBuilder(Names.MANAGEMENT, <span class="number">1</span>, <span class="number">5</span>, TimeValue.timeValueMinutes(<span class="number">5</span>)));</span><br><span class="line">        <span class="comment">// no queue as this means clients will need to handle rejections on listener queue even if the operation succeeded</span></span><br><span class="line">        <span class="comment">// the assumption here is that the listeners should be very lightweight on the listeners side</span></span><br><span class="line">        builders.put(Names.LISTENER, <span class="keyword">new</span> FixedExecutorBuilder(settings, Names.LISTENER, halfProcMaxAt10, -<span class="number">1</span>));</span><br><span class="line">        builders.put(Names.FLUSH, <span class="keyword">new</span> ScalingExecutorBuilder(Names.FLUSH, <span class="number">1</span>, halfProcMaxAt5, TimeValue.timeValueMinutes(<span class="number">5</span>)));</span><br><span class="line">        builders.put(Names.REFRESH, <span class="keyword">new</span> ScalingExecutorBuilder(Names.REFRESH, <span class="number">1</span>, halfProcMaxAt10, TimeValue.timeValueMinutes(<span class="number">5</span>)));</span><br><span class="line">        builders.put(Names.WARMER, <span class="keyword">new</span> ScalingExecutorBuilder(Names.WARMER, <span class="number">1</span>, halfProcMaxAt5, TimeValue.timeValueMinutes(<span class="number">5</span>)));</span><br><span class="line">        builders.put(Names.SNAPSHOT, <span class="keyword">new</span> ScalingExecutorBuilder(Names.SNAPSHOT, <span class="number">1</span>, halfProcMaxAt5, TimeValue.timeValueMinutes(<span class="number">5</span>)));</span><br><span class="line">        builders.put(Names.FETCH_SHARD_STARTED, <span class="keyword">new</span> ScalingExecutorBuilder(Names.FETCH_SHARD_STARTED, <span class="number">1</span>, <span class="number">2</span> * availableProcessors, TimeValue.timeValueMinutes(<span class="number">5</span>)));</span><br><span class="line">        builders.put(Names.FORCE_MERGE, <span class="keyword">new</span> FixedExecutorBuilder(settings, Names.FORCE_MERGE, <span class="number">1</span>, -<span class="number">1</span>));</span><br><span class="line">        builders.put(Names.FETCH_SHARD_STORE, <span class="keyword">new</span> ScalingExecutorBuilder(Names.FETCH_SHARD_STORE, <span class="number">1</span>, <span class="number">2</span> * availableProcessors, TimeValue.timeValueMinutes(<span class="number">5</span>)));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ExecutorBuilder&lt;?&gt; builder : customBuilders) &#123;</span><br><span class="line">            <span class="keyword">if</span> (builders.containsKey(builder.name())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"builder with name ["</span> + builder.name() + <span class="string">"] already exists"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            builders.put(builder.name(), builder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.builders = Collections.unmodifiableMap(builders);</span><br><span class="line"></span><br><span class="line">        threadContext = <span class="keyword">new</span> ThreadContext(settings);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, ExecutorHolder&gt; executors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="keyword">final</span> Map.Entry&lt;String, ExecutorBuilder&gt; entry : builders.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> ExecutorBuilder.ExecutorSettings executorSettings = entry.getValue().getSettings(settings);</span><br><span class="line">            <span class="keyword">final</span> ExecutorHolder executorHolder = entry.getValue().build(executorSettings, threadContext);</span><br><span class="line">            <span class="keyword">if</span> (executors.containsKey(executorHolder.info.getName())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"duplicate executors with name ["</span> + executorHolder.info.getName() + <span class="string">"] registered"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.debug(<span class="string">"created thread pool: &#123;&#125;"</span>, entry.getValue().formatInfo(executorHolder.info));</span><br><span class="line">            executors.put(entry.getKey(), executorHolder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executors.put(Names.SAME, <span class="keyword">new</span> ExecutorHolder(DIRECT_EXECUTOR, <span class="keyword">new</span> Info(Names.SAME, ThreadPoolType.DIRECT)));</span><br><span class="line">        <span class="keyword">this</span>.executors = unmodifiableMap(executors);</span><br><span class="line">        <span class="comment">// 最后创建一个1线程的scheduler来执行定时任务</span></span><br><span class="line">        <span class="keyword">this</span>.scheduler = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, EsExecutors.daemonThreadFactory(settings, <span class="string">"scheduler"</span>), <span class="keyword">new</span> EsAbortPolicy());</span><br><span class="line">        <span class="keyword">this</span>.scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.scheduler.setRemoveOnCancelPolicy(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        TimeValue estimatedTimeInterval = ESTIMATED_TIME_INTERVAL_SETTING.get(settings);</span><br><span class="line">        <span class="comment">// 最后创建一个执行timer的线程</span></span><br><span class="line">        <span class="keyword">this</span>.cachedTimeThread = <span class="keyword">new</span> CachedTimeThread(EsExecutors.threadName(settings, <span class="string">"[timer]"</span>), estimatedTimeInterval.millis());</span><br><span class="line">        <span class="keyword">this</span>.cachedTimeThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原来在ES的threadPool中，根据不同的类型分别分配了不同线程数的一个线程池，而executor由一个executorBuilder来提供，所以submit task的时候也需要指定不同的Name。最后创建一个1线程的scheduler来执行定时任务。最后创建一个执行timer的线程。</p><p>再继续往下看Node的构造方法就会看到接下来会new 一堆的services和modules，这里就不一一过了，其共性就是都会绑定刚刚创建的threadPool，已经也会绑定必要的services，某些module本身具有后台线程的话，初始化完成需要调用<code>.start()</code>去启动这些后台线程。</p><ul><li>初始化modules实例，通过Guice的Injector进行注入各个Module实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ModulesBuilder modules = <span class="keyword">new</span> ModulesBuilder();</span><br><span class="line">***</span><br><span class="line">modules.add(b -&gt; &#123;</span><br><span class="line">                    b.bind(NodeService.class).toInstance(nodeService);</span><br><span class="line">                    b.bind(NamedXContentRegistry.class).toInstance(xContentRegistry);</span><br><span class="line">                    b.bind(PluginsService.class).toInstance(pluginsService);</span><br><span class="line">                    b.bind(Client.class).toInstance(client);</span><br><span class="line">                    b.bind(NodeClient.class).toInstance(client);</span><br><span class="line">                    b.bind(Environment.class).toInstance(<span class="keyword">this</span>.environment);</span><br><span class="line">                    b.bind(ThreadPool.class).toInstance(threadPool);</span><br><span class="line">                    b.bind(NodeEnvironment.class).toInstance(nodeEnvironment);</span><br><span class="line">                    b.bind(TribeService.class).toInstance(tribeService);</span><br><span class="line">                    b.bind(ResourceWatcherService.class).toInstance(resourceWatcherService);</span><br><span class="line">                    b.bind(CircuitBreakerService.class).toInstance(circuitBreakerService);</span><br><span class="line">                    b.bind(BigArrays.class).toInstance(bigArrays);</span><br><span class="line">                    b.bind(ScriptService.class).toInstance(scriptModule.getScriptService());</span><br><span class="line">                    b.bind(AnalysisRegistry.class).toInstance(analysisModule.getAnalysisRegistry());</span><br><span class="line">                    b.bind(IngestService.class).toInstance(ingestService);</span><br><span class="line">                    b.bind(NamedWriteableRegistry.class).toInstance(namedWriteableRegistry);</span><br><span class="line">                    b.bind(MetaDataUpgrader.class).toInstance(metaDataUpgrader);</span><br><span class="line">                    b.bind(MetaStateService.class).toInstance(metaStateService);</span><br><span class="line">                    b.bind(IndicesService.class).toInstance(indicesService);</span><br><span class="line">                    b.bind(SearchService.class).toInstance(newSearchService(clusterService, indicesService,</span><br><span class="line">                        threadPool, scriptModule.getScriptService(), bigArrays, searchModule.getFetchPhase()));</span><br><span class="line">                    b.bind(SearchTransportService.class).toInstance(searchTransportService);</span><br><span class="line">                    b.bind(SearchPhaseController.class).toInstance(<span class="keyword">new</span> SearchPhaseController(settings, bigArrays,</span><br><span class="line">                            scriptModule.getScriptService()));</span><br><span class="line">                    b.bind(Transport.class).toInstance(transport);</span><br><span class="line">                    b.bind(TransportService.class).toInstance(transportService);</span><br><span class="line">                    b.bind(NetworkService.class).toInstance(networkService);</span><br><span class="line">                    b.bind(UpdateHelper.class).toInstance(<span class="keyword">new</span> UpdateHelper(settings, scriptModule.getScriptService()));</span><br><span class="line">                    b.bind(MetaDataIndexUpgradeService.class).toInstance(<span class="keyword">new</span> MetaDataIndexUpgradeService(settings, xContentRegistry,</span><br><span class="line">                        indicesModule.getMapperRegistry(), settingsModule.getIndexScopedSettings(), indexMetaDataUpgraders));</span><br><span class="line">                    b.bind(ClusterInfoService.class).toInstance(clusterInfoService);</span><br><span class="line">                    b.bind(Discovery.class).toInstance(discoveryModule.getDiscovery());</span><br><span class="line">                    &#123;</span><br><span class="line">                        RecoverySettings recoverySettings = <span class="keyword">new</span> RecoverySettings(settings, settingsModule.getClusterSettings());</span><br><span class="line">                        processRecoverySettings(settingsModule.getClusterSettings(), recoverySettings);</span><br><span class="line">                        b.bind(PeerRecoverySourceService.class).toInstance(<span class="keyword">new</span> PeerRecoverySourceService(settings, transportService,</span><br><span class="line">                                indicesService, recoverySettings, clusterService));</span><br><span class="line">                        b.bind(PeerRecoveryTargetService.class).toInstance(<span class="keyword">new</span> PeerRecoveryTargetService(settings, threadPool,</span><br><span class="line">                                transportService, recoverySettings, clusterService));</span><br><span class="line">                    &#125;</span><br><span class="line">                    httpBind.accept(b);</span><br><span class="line">                    pluginComponents.stream().forEach(p -&gt; b.bind((Class) p.getClass()).toInstance(p));</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            injector = modules.createInjector();</span><br></pre></td></tr></table></figure><p>这里面会注入Discovery，ClusterService，Transport Service，还创建了NodeClient用来接收全部其他节点请求。这些都会在往后重点剖析。</p><h6 id="3-4-2-启动Node"><a href="#3-4-2-启动Node" class="headerlink" title="3.4.2 启动Node"></a>3.4.2 启动Node</h6><p>通过在Bootstrap#start()方法中调用Node.start()来启动节点</p><p>我们知道，在Node的初始化方法中，Model组件会被添加到绑定的线程当中，那么启动这些只需要调用相应组件的.start()方法即可完成组件的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> NodeValidationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lifecycle.moveToStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Logger logger = Loggers.getLogger(Node.class, NODE_NAME_SETTING.get(settings));</span><br><span class="line">        logger.info(<span class="string">"starting ..."</span>);</span><br><span class="line">        <span class="comment">// hack around dependency injection problem (for now...)</span></span><br><span class="line">        injector.getInstance(Discovery.class).setAllocationService(injector.getInstance(AllocationService.class));</span><br><span class="line">        pluginLifecycleComponents.forEach(LifecycleComponent::start);</span><br><span class="line"></span><br><span class="line">        injector.getInstance(MappingUpdatedAction.class).setClient(client);</span><br><span class="line">        injector.getInstance(IndicesService.class).start();</span><br><span class="line">        injector.getInstance(IndicesClusterStateService.class).start();</span><br><span class="line">        injector.getInstance(IndicesTTLService.class).start();</span><br><span class="line">        injector.getInstance(SnapshotsService.class).start();</span><br><span class="line">        injector.getInstance(SnapshotShardsService.class).start();</span><br><span class="line">        injector.getInstance(RoutingService.class).start();</span><br><span class="line">        injector.getInstance(SearchService.class).start();</span><br><span class="line">        injector.getInstance(MonitorService.class).start();</span><br></pre></td></tr></table></figure><p>3.4.3 Node节点停止</p><p>该方法跟node启动差不多，也是调用相关组件的stop方法即可，这里就不再分析了</p><h6 id="3-4-4-加载配置文件信息"><a href="#3-4-4-加载配置文件信息" class="headerlink" title="3.4.4 加载配置文件信息"></a>3.4.4 加载配置文件信息</h6><ul><li>入口</li></ul><p>通过Node的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Settings preparedSettings)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(InternalSettingsPreparer.prepareEnvironment(preparedSettings, <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是加载配置文件的入口，它有三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Settings <span class="title">prepareSettings</span><span class="params">(Settings input)</span> </span>&#123;</span><br><span class="line">        Settings.Builder output = Settings.builder();</span><br><span class="line">        initializeSettings(output, input, Collections.emptyMap());</span><br><span class="line">        finalizeSettings(output, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> output.build();</span><br><span class="line">    &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Environment <span class="title">prepareEnvironment</span><span class="params">(Settings input, Terminal terminal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prepareEnvironment(input, terminal, Collections.emptyMap());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Environment <span class="title">prepareEnvironment</span><span class="params">(Settings input, Terminal terminal, Map&lt;String, String&gt; properties)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>在InternalSettingsPreparer类的prepareEnvironment(org.elasticsearch.common.settings.Settings, org.elasticsearch.cli.Terminal, java.util.Map&lt;java.lang.String,java.lang.String&gt;, java.nio.file.Path)方法中进行了配置文件的加载。</p><ul><li><p>加载配置文件的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Environment <span class="title">prepareEnvironment</span><span class="params">(Settings input, Terminal terminal, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// just create enough settings to build the environment, to get the config dir</span></span><br><span class="line">        Settings.Builder output = Settings.builder();</span><br><span class="line">        <span class="comment">// 初始化输入输出流信息</span></span><br><span class="line">        initializeSettings(output, input, properties);</span><br><span class="line">        <span class="comment">// 构造Environment实例</span></span><br><span class="line">        Environment environment = <span class="keyword">new</span> Environment(output.build());</span><br><span class="line">        <span class="comment">// 这个很关键，保证elasticsearch.yml文件中配置的日志路径path.logs生效</span></span><br><span class="line">        output = Settings.builder(); <span class="comment">// start with a fresh output</span></span><br><span class="line">        <span class="keyword">boolean</span> settingsFileFound = <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;String&gt; foundSuffixes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String allowedSuffix : ALLOWED_SUFFIXES) &#123;</span><br><span class="line">            Path path = environment.configFile().resolve(<span class="string">"elasticsearch"</span> + allowedSuffix);</span><br><span class="line">            <span class="keyword">if</span> (Files.exists(path)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!settingsFileFound) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        output.loadFromPath(path);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SettingsException(<span class="string">"Failed to load settings from "</span> + path.toString(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                settingsFileFound = <span class="keyword">true</span>;</span><br><span class="line">                foundSuffixes.add(allowedSuffix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (foundSuffixes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SettingsException(<span class="string">"multiple settings files found with suffixes: "</span></span><br><span class="line">                + Strings.collectionToDelimitedString(foundSuffixes, <span class="string">","</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// re-initialize settings now that the config file has been loaded</span></span><br><span class="line">        initializeSettings(output, input, properties);</span><br><span class="line">        finalizeSettings(output, terminal);</span><br><span class="line">        <span class="comment">// 再次获取Environment实例</span></span><br><span class="line">        environment = <span class="keyword">new</span> Environment(output.build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we put back the path.logs so we can use it in the logging configuration file</span></span><br><span class="line">        output.put(Environment.PATH_LOGS_SETTING.getKey(), cleanPath(environment.logsFile().toAbsolutePath().toString()));</span><br><span class="line">        String configExtension = foundSuffixes.isEmpty() ? <span class="keyword">null</span> : foundSuffixes.iterator().next();</span><br><span class="line">        <span class="comment">// 返回Environment实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Environment(output.build(), configExtension);</span><br></pre></td></tr></table></figure><p>构建一个默认的Settings的实例</p><p>然后用构造出来的新的Settings来加载给定或默认路径下的<em>elasticsearch.yml</em></p><p>然后将方法接受的参数Settings实例也加载到这个新的Settings中。</p><p>最后才将日志文件的路径加载进Settings中，这样就保证了<em>elasticsearch.yml</em>文件中配置的日志路径<em>path.logs</em>生效（覆盖该方法参数中的配置）。</p><p>最后返回一个Environment的实例，使得Node开始构建</p></li></ul><h4 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h4><p>通过上述的源码分析，我们知道Elasticsearch节点启动的入口是Elasticsearch#main()方法，在该方法中会进行一些安全管理的设置，去调用Command的main()方法，整个方法执行没有任何异常，则返回ok状态。</p><p>Command#main()：会去添加一些钩子、配置日志输出、调用mainWithoutErrorHandling()去执行EnvironmentAwareCommand#execute(terminal, options)方法。</p><p>EnvironmentAwareCommand#execute(terminal, options)方法：只是将配置信息设置到HashMap中，检查了elasticsearch的参数path.conf、path.data、path.home、path.logs，最后调用Elasticsearch#execute()方法，execute(terminal, options, createEnv(terminal, settings))会先调用EnvironmentAwareCommand# createEnv(terminal, settings)</p><p>Elasticsearch#execute()方法：主要是处理参数，调用init(daemonize, pidFile, quiet, env)，真正执行启动的是Bootstrap.init(!daemonize, pidFile, quiet, initialEnv)方法。</p><p>Bootstrap.init(!daemonize, pidFile, quiet, initialEnv)：主要是调用setup()方法和start()方法，在setup()方法中主要通过environment生成本地插件控制器spawner、添加钩子、添加安全管理器、检查jar包、创建Node节点。而start()通过启动初始化好的Node和keepAliveThread线程，这个keepAliveThread使用了CountdownLatch计数器为1来保证钩子一定能够关闭。</p><p>Node类的初始化：通过设置好的environment来初始化节点，设置nodEnvironment、Environment、设置Node_name、设置线程池（其实是一个HashMap&lt;String,ExecutorBuilder&gt;） ，根据不同的类型分别分配了不同线程数的一个线程池。将创建好的module绑定到创建的ThreadPool。</p><p>大致的时序图如下：</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/Elasticsearch%E6%BA%90%E7%A0%81%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=":\hexo\source\images\es\Elasticsearch源码启动时序图.pn"></p><p>现在还遗留着几个问题：</p><ul><li>master选举是在什么模块进行的</li></ul><ul><li>怎么进行master选举</li><li>怎么进行节点监控、维护的</li></ul><p>留到下一篇再进行分析。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于最近半年来一直在使用Elasticsearch来做全文检索和ELK统一日志工作，对于ES还是觉得需要细细研究，才能感受到它的魅力，才能有所提高。&lt;/p&gt;
&lt;p&gt;我们先提出几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动入口在哪个类？&lt;/li&gt;
&lt;li&gt;启动需要做哪些初始化工作
      
    
    </summary>
    
      <category term="Elasticsearch源码分析专题" scheme="http://yoursite.com/categories/Elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%93%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>elasticsearch源码分析(一)--整体架构</title>
    <link href="http://yoursite.com/2018/05/24/elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)--%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2018/05/24/elasticsearch源码分析(一)--整体架构/</id>
    <published>2018-05-24T02:12:57.000Z</published>
    <updated>2018-06-25T00:07:21.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、源码主要模块"><a href="#一、源码主要模块" class="headerlink" title="一、源码主要模块"></a>一、源码主要模块</h1><p>我下载的Elasticsearch的源码版本为5.6.4</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/es01.png" alt="es整体结构"></p><p>从上图来看：Elasticsearch主要包含以下几个模块</p><p>distribution：elasticsearch的打包发行相关，将elasticsearch打成各种发行包（zip，deb，rpm，tar）的模块。具体用法如是，在相应的发行版本模块下执行publishToMavenLocal这个Task，如果执行成功的话就会在路径build/distributions下生成对应的发行包，这种打好的包就能在生产服务器上运行。如果自己修改了源码，打包时就需要用到该模块了。</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/es02-2.png" alt=":\我的资料\ELK日志监控\es源码分析\distribution整体架构.pn"></p><p><img src="G:\我的资料\ELK日志监控\es源码分析\distribution整体架构-打包zip.png" alt=":\我的资料\ELK日志监控\es源码分析\distribution整体架构-打包zip.pn"></p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/es02-3.png" alt=":\我的资料\ELK日志监控\es源码分析\distribution整体架构-打包zip成功.pn"></p><p>core：核心包，elasticsearch的源码主要在这个里面，Elasticsearch索引管理、集群管理、服务发现、查询、对Lucene操作的封装等都位于该模块</p><p>buildSrc：elasticsearch的构建相关的代码，gradle相关依赖配置都在改模块下</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/buildSrc%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt=":\我的资料\ELK日志监控\es源码分析\buildSrc整体架构.pn"></p><p>client：作为连接elasticsearch的客户端相关代码，它提供了Rest方式（基于Http）、transport （Java Netty内部的通信方式）等方式。</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/client%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt=":\我的资料\ELK日志监控\es源码分析\client整体架构.pn"></p><p>modules：作为elasticsearch除核心外的必备模块相关代码,比如对Netty的封装、父子类查询、重建索引</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/modules%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt=":\我的资料\ELK日志监控\es源码分析\modules整体架构.pn"></p><p>plugins：作为elasticsearch必备的插件的相关代码，丰富ES的相关功能，比如IK分词器插件、mapper-attachments/ingest-attachment文件处理插件。</p><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/plugings%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt=":\我的资料\ELK日志监控\es源码分析\plugings整体架构.pn"></p><h1 id="二、Elasticsearch整体架构图"><a href="#二、Elasticsearch整体架构图" class="headerlink" title="二、Elasticsearch整体架构图"></a>二、Elasticsearch整体架构图</h1><p><img src="https://github.com/Zhanggdong/Zhanggdong.github.io/raw/master/images/es/ES%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=":\我的资料\ELK日志监控\es源码分析\ES架构图.pn"></p><p>服务发现以及选主 ZenDiscovery</p><p>恢复以及容灾</p><p>搜索引擎 Search</p><p>ClusterState</p><p>网络层</p><p>Rest 和 RPC</p><p>线程池</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、源码主要模块&quot;&gt;&lt;a href=&quot;#一、源码主要模块&quot; class=&quot;headerlink&quot; title=&quot;一、源码主要模块&quot;&gt;&lt;/a&gt;一、源码主要模块&lt;/h1&gt;&lt;p&gt;我下载的Elasticsearch的源码版本为5.6.4&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="Elasticsearch源码分析专题" scheme="http://yoursite.com/categories/Elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%93%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch源码阅读环境搭建</title>
    <link href="http://yoursite.com/2018/05/23/elasticsearch%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/05/23/elasticsearch源码环境搭建/</id>
    <published>2018-05-23T04:12:57.000Z</published>
    <updated>2018-06-25T00:07:07.275Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Elasticsearch源码分析专题" scheme="http://yoursite.com/categories/Elasticsearch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%93%E9%A2%98/"/>
    
    
  </entry>
  
</feed>
